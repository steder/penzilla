<HTML><HEAD><TITLE>/home/steder/Projects/Tutorials/python/BobChat-v0.3/BobClient.py</TITLE></HEAD>
                  <BODY BGCOLOR=#FFFFFF>
                  <!--header-->
                  <!--script--><PRE><FONT COLOR=#1111CC>#!/usr/local/bin/python</FONT>

<FONT COLOR=#115511>""" This module tries to retrieve as much platform identifying data as
    possible. It makes this information available via function APIs.

    If called from the command line, it prints the platform
    information concatenated as single string to stdout. The output
    format is useable as part of a filename.

    Note that this module is a fast moving target. I plan to release
    version 1.0 as the final version.

    Still needed:
     more support for WinCE
     support for MS-DOS (PythonDX ?)
     support for Amiga and other still unsupported platforms running Python
     support for additional Linux distributions

    Many thanks to all those who helped adding platform specific
    checks (in no particular order):

      Charles G Waldman, David Arnold, Gordon McMillan, Ben Darnell,
      Jeff Bauer, Cliff Crawford, Ivan Van Laningham, Josef
      Betancourt, Randall Hopper, Karl Putland, John Farrell, Greg
      Andruk, Just van Rossum, Thomas Heller, Mark R. Levinson, Mark
      Hammond, Bill Tutt, Hans Nowak, Uwe Zessin (OpenVMS support),
      Colin Kong
 
    History:
    0.7.1 - added support for Caldera OpenLinux
    0.7.0 - some fixes for WinCE; untabified the source file
    0.6.2 - support for OpenVMS - requires version 1.5.2-V006 or higher and
            vms_lib.getsyi() configured
    0.6.1 - added code to prevent 'uname -p' on platforms which are
            known not to support it
    0.6.0 - fixed win32_ver() to hopefully work on Win95,98,NT and Win2k;
            did some cleanup of the interfaces - some APIs have changed
    0.5.5 - fixed another type in the MacOS code... should have
            used more coffee today ;-)
    0.5.4 - fixed a few typos in the MacOS code
    0.5.3 - added experimental MacOS support; added better popen()
            workarounds in _syscmd_ver() -- still not 100% elegant
            though
    0.5.2 - fixed uname() to return '' instead of 'unkown' in all
            return values (the system uname command tends to return
            'unkown' instead of just leaving the field emtpy)
    0.5.1 - included code for slackware dist; added exception handlers
            to cover up situations where platforms don't have os.popen
            (e.g. Mac) or fail on socket.gethostname(); fixed libc
            detection RE
    0.5.0 - changed the API names referring to system commands to *syscmd*;
            added java_ver(); made syscmd_ver() a private
            API (was system_ver() in previous versions) -- use uname()
            instead; extended the win32_ver() to also return processor
            type information
    0.4.0 - added win32_ver() and modified the platform() output for WinXX
    0.3.4 - fixed a bug in _follow_symlinks()
    0.3.3 - fixed popen() and "file" command invokation bugs
    0.3.2 - added architecture() API and support for it in platform()
    0.3.1 - fixed syscmd_ver() RE to support Windows NT
    0.3.0 - added system alias support
    0.2.3 - removed 'wince' again... oh well.
    0.2.2 - added 'wince' to syscmd_ver() supported platforms
    0.2.1 - added cache logic and changed the platform string format
    0.2.0 - changed the API to use functions instead of module globals
            since some action take too long to be run on module import
    0.1.0 - first release

    You can always get the latest version of this module at:

             http://starship.skyport.net/~lemburg/platform.py

    If that URL should fail, try contacting the author.

    ----------------------------------------------------------------------

    (c) Copyright by Marc-Andre Lemburg (mailto:mal@lemburg.com)

    Permission to use, copy, modify, and distribute this software and its
    documentation for any purpose and without fee or royalty is hereby granted,
    provided that the above copyright notice appear in all copies and that
    both that copyright notice and this permission notice appear in
    supporting documentation or portions thereof, including modifications,
    that you make.

    THE AUTHOR MARC-ANDRE LEMBURG DISCLAIMS ALL WARRANTIES WITH REGARD TO
    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS, IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,
    INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
    FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
    NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
    WITH THE USE OR PERFORMANCE OF THIS SOFTWARE !

"""</FONT>

__version__ = <FONT COLOR=#115511>'0.7.0'</FONT>

<FONT COLOR=#3333CC><B>import</B></FONT> sys,string,os,re

<FONT COLOR=#1111CC>### Platform specific APIs</FONT>

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="libc_ver"><FONT COLOR=#CC0000><B> libc_ver</B></FONT></A>(executable=sys.executable,lib=<FONT COLOR=#115511>''</FONT>,version=<FONT COLOR=#115511>''</FONT>,

             chunksize=2048,
             libc_search=re.compile(<FONT COLOR=#115511>'(__libc_init)'</FONT>
                                    <FONT COLOR=#115511>'|'</FONT>
                                    <FONT COLOR=#115511>'(GLIBC_([0-9.]+))'</FONT> 
                                    <FONT COLOR=#115511>'|'</FONT> 
                                    <FONT COLOR=#115511>'(libc(_\w+)?\.so(?:\.(\d[0-9.]*))?)'</FONT>
                                    )
         ):

    <FONT COLOR=#115511>""" Tries to determine the libc version against which the
        file executable (defaults to the Python interpreter) is linked.

        Returns a tuple of strings (lib,version) which default to the
        given parameters in case the lookup fails.

        Note that the function has intimate knowledge of how different
        libc versions add symbols to the executable is probably only
        useable for executables compiled using gcc. 

        The file is read and scanned in chunks of chunksize bytes.

    """</FONT>
    f = open(executable,<FONT COLOR=#115511>'rb'</FONT>)
    binary = f.read(chunksize)
    pos = 0
    <FONT COLOR=#3333CC><B>while</B></FONT> 1:
        m = libc_search.search(binary,pos)
        <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> m:
            binary = f.read(chunksize)
            <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> binary:
                <FONT COLOR=#3333CC><B>break</B></FONT>
            pos = 0
            <FONT COLOR=#3333CC><B>continue</B></FONT>
        libcinit,glibc,glibcversion,so,threads,soversion = m.groups()
        <FONT COLOR=#3333CC><B>if</B></FONT> libcinit <FONT COLOR=#3333CC><B>and</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> lib:
            lib = <FONT COLOR=#115511>'libc'</FONT>
        <FONT COLOR=#3333CC><B>elif</B></FONT> glibc:
            <FONT COLOR=#3333CC><B>if</B></FONT> lib != <FONT COLOR=#115511>'glibc'</FONT>:
                lib = <FONT COLOR=#115511>'glibc'</FONT>
                version = glibcversion
            <FONT COLOR=#3333CC><B>elif</B></FONT> glibcversion &gt; version:
                version = glibcversion
        <FONT COLOR=#3333CC><B>elif</B></FONT> so:
            <FONT COLOR=#3333CC><B>if</B></FONT> lib != <FONT COLOR=#115511>'glibc'</FONT>:
                lib = <FONT COLOR=#115511>'libc'</FONT>
                <FONT COLOR=#3333CC><B>if</B></FONT> soversion &gt; version:
                    version = soversion
                <FONT COLOR=#3333CC><B>if</B></FONT> threads <FONT COLOR=#3333CC><B>and</B></FONT> version[-len(threads):] != threads:
                    version = version + threads
        pos = m.end()
    f.close()
    <FONT COLOR=#3333CC><B>return</B></FONT> lib,version

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="_dist_try_harder"><FONT COLOR=#CC0000><B> _dist_try_harder</B></FONT></A>(distname,version,id):

    <FONT COLOR=#115511>""" Tries some special tricks to get the distribution 
        information in case the default method fails.

        Currently supports older SuSE Linux, Caldera OpenLinux and
        Slackware Linux distributions.

    """</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> os.path.exists(<FONT COLOR=#115511>'/var/adm/inst-log/info'</FONT>):
        <FONT COLOR=#1111CC># SuSE Linux stores distribution information in that file</FONT>
        info = open(<FONT COLOR=#115511>'/var/adm/inst-log/info'</FONT>).readlines()
        distname = <FONT COLOR=#115511>'SuSE'</FONT>
        <FONT COLOR=#3333CC><B>for</B></FONT> line <FONT COLOR=#3333CC><B>in</B></FONT> info:
            tv = string.split(line)
            <FONT COLOR=#3333CC><B>if</B></FONT> len(tv) == 2:
                tag,value = tv
            <FONT COLOR=#3333CC><B>else</B></FONT>:
                <FONT COLOR=#3333CC><B>continue</B></FONT>
            <FONT COLOR=#3333CC><B>if</B></FONT> tag == <FONT COLOR=#115511>'MIN_DIST_VERSION'</FONT>:
                version = string.strip(value)
            <FONT COLOR=#3333CC><B>elif</B></FONT> tag == <FONT COLOR=#115511>'DIST_IDENT'</FONT>:
                values = string.split(value,<FONT COLOR=#115511>'-'</FONT>)
                id = values[2]
        <FONT COLOR=#3333CC><B>return</B></FONT> distname,version,id

    <FONT COLOR=#3333CC><B>if</B></FONT> os.path.exists(<FONT COLOR=#115511>'/etc/.installed'</FONT>):
        <FONT COLOR=#1111CC># Caldera OpenLinux has some infos in that file (thanks to Colin Kong)</FONT>
        info = open(<FONT COLOR=#115511>'/etc/.installed'</FONT>).readlines()
        <FONT COLOR=#3333CC><B>for</B></FONT> line <FONT COLOR=#3333CC><B>in</B></FONT> info:
            pkg = string.split(line,<FONT COLOR=#115511>'-'</FONT>)
            <FONT COLOR=#3333CC><B>if</B></FONT> len(pkg) &gt;= 2 <FONT COLOR=#3333CC><B>and</B></FONT> pkg[0] == <FONT COLOR=#115511>'OpenLinux'</FONT>:
                <FONT COLOR=#1111CC># XXX does Caldera support non Intel platforms ? If yes,</FONT>
                <FONT COLOR=#1111CC>#     where can we find the needed id ?</FONT>
                <FONT COLOR=#3333CC><B>return</B></FONT> <FONT COLOR=#115511>'OpenLinux'</FONT>,pkg[1],id

    <FONT COLOR=#3333CC><B>if</B></FONT> os.path.isdir(<FONT COLOR=#115511>'/usr/lib/setup'</FONT>):
        <FONT COLOR=#1111CC># Check for slackware verson tag file (thanks to Greg Andruk)</FONT>
        verfiles = os.listdir(<FONT COLOR=#115511>'/usr/lib/setup'</FONT>)
        <FONT COLOR=#3333CC><B>for</B></FONT> n <FONT COLOR=#3333CC><B>in</B></FONT> range(len(verfiles)-1, -1, -1):
            <FONT COLOR=#3333CC><B>if</B></FONT> verfiles[n][:14] != <FONT COLOR=#115511>'slack-version-'</FONT>:
                <FONT COLOR=#3333CC><B>del</B></FONT> verfiles[n]
        <FONT COLOR=#3333CC><B>if</B></FONT> verfiles:
            verfiles.sort()
            distname = <FONT COLOR=#115511>'slackware'</FONT>
            version = verfiles[-1][14:]
            <FONT COLOR=#3333CC><B>return</B></FONT> distname,version,id

    <FONT COLOR=#3333CC><B>return</B></FONT> distname,version,id

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="dist"><FONT COLOR=#CC0000><B> dist</B></FONT></A>(distname=<FONT COLOR=#115511>''</FONT>,version=<FONT COLOR=#115511>''</FONT>,id=<FONT COLOR=#115511>''</FONT>,

         supported_dists=(<FONT COLOR=#115511>'SuSE'</FONT>,<FONT COLOR=#115511>'debian'</FONT>,<FONT COLOR=#115511>'redhat'</FONT>,<FONT COLOR=#115511>'mandrake'</FONT>),
         release_filename=re.compile(<FONT COLOR=#115511>'(\w+)[-_](release|version)'</FONT>),
         release_version=re.compile(<FONT COLOR=#115511>'([\d.]+)[^(]*(?:\((.+)\))?'</FONT>)):

    <FONT COLOR=#115511>""" Tries to determine the name of the OS distribution name

        The function first looks for a distribution release file in
        /etc and then reverts to _dist_try_harder() in case no
        suitable files are found.

        Returns a tuple distname,version,id which default to the
        args given as parameters.

    """</FONT>
    <FONT COLOR=#3333CC><B>try</B></FONT>:
        etc = os.listdir(<FONT COLOR=#115511>'/etc'</FONT>)
    <FONT COLOR=#3333CC><B>except</B></FONT> os.error:
        <FONT COLOR=#1111CC># Probably not a Unix system</FONT>
        <FONT COLOR=#3333CC><B>return</B></FONT> distname,version,id
    <FONT COLOR=#3333CC><B>for</B></FONT> file <FONT COLOR=#3333CC><B>in</B></FONT> etc:
        m = release_filename.match(file)
        <FONT COLOR=#3333CC><B>if</B></FONT> m:
            _distname,dummy = m.groups()
            <FONT COLOR=#3333CC><B>if</B></FONT> _distname <FONT COLOR=#3333CC><B>in</B></FONT> supported_dists:
                distname = _distname
                <FONT COLOR=#3333CC><B>break</B></FONT>
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        <FONT COLOR=#3333CC><B>return</B></FONT> _dist_try_harder(distname,version,id)
    f = open(<FONT COLOR=#115511>'/etc/'</FONT>+file,<FONT COLOR=#115511>'r'</FONT>)
    firstline = f.readline()
    f.close()
    m = release_version.search(firstline)
    <FONT COLOR=#3333CC><B>if</B></FONT> m:
        _version,_id = m.groups()
        <FONT COLOR=#3333CC><B>if</B></FONT> _version:
            version = _version
        <FONT COLOR=#3333CC><B>if</B></FONT> _id:
            id = _id
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        <FONT COLOR=#1111CC># Unkown format... take the first two words</FONT>
        l = string.split(string.strip(firstline))
        <FONT COLOR=#3333CC><B>if</B></FONT> l:
            version = l[0]
            <FONT COLOR=#3333CC><B>if</B></FONT> len(l) &gt; 1:
                id = l[1]
    <FONT COLOR=#3333CC><B>return</B></FONT> distname,version,id

<FONT COLOR=#3333CC><B>class</B></FONT><A NAME="_popen"><FONT COLOR=#CC0000><B> _popen</B></FONT></A>:

    <FONT COLOR=#115511>""" Fairly portable (alternative) popen implementation.

        This is mostly needed in case os.popen() is not available, or
        doesn't work as advertised, e.g. in Win9X GUI programs like
        PythonWin or IDLE.

    """</FONT>
    tmpfile = <FONT COLOR=#115511>''</FONT>
    pipe = None

    <FONT COLOR=#3333CC><B>def</B></FONT><A NAME="__init__"><FONT COLOR=#CC0000><B> __init__</B></FONT></A>(self,cmd):

        <FONT COLOR=#3333CC><B>import</B></FONT> tempfile
        self.tmpfile = tmpfile = tempfile.mktemp()
        os.system(cmd + <FONT COLOR=#115511>' &gt; %s'</FONT> % tmpfile)
        self.pipe = open(tmpfile,<FONT COLOR=#115511>'rb'</FONT>)

    <FONT COLOR=#3333CC><B>def</B></FONT><A NAME="read"><FONT COLOR=#CC0000><B> read</B></FONT></A>(self):

        <FONT COLOR=#3333CC><B>return</B></FONT> self.pipe.read()

    <FONT COLOR=#3333CC><B>def</B></FONT><A NAME="readlines"><FONT COLOR=#CC0000><B> readlines</B></FONT></A>(self):

        <FONT COLOR=#3333CC><B>return</B></FONT> self.pipe.readlines()

    <FONT COLOR=#3333CC><B>def</B></FONT><A NAME="close"><FONT COLOR=#CC0000><B> close</B></FONT></A>(self,

              remove=os.unlink,error=os.error):

        <FONT COLOR=#3333CC><B>if</B></FONT> self.pipe:
            rc = self.pipe.close()
        <FONT COLOR=#3333CC><B>else</B></FONT>:
            rc = 255
        <FONT COLOR=#3333CC><B>if</B></FONT> self.tmpfile:
            <FONT COLOR=#3333CC><B>try</B></FONT>:
                remove(self.tmpfile)
            <FONT COLOR=#3333CC><B>except</B></FONT> error:
                <FONT COLOR=#3333CC><B>pass</B></FONT>
        <FONT COLOR=#3333CC><B>return</B></FONT> rc

    <FONT COLOR=#1111CC># Alias</FONT>
    __del__ = close

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="_norm_version"><FONT COLOR=#CC0000><B> _norm_version</B></FONT></A>(version,build=<FONT COLOR=#115511>''</FONT>):

    <FONT COLOR=#115511>""" Normalize the version and build strings and return a sinlge
        vesion string using the format major.minor.build (or patchlevel).
    """</FONT>
    l = string.split(version,<FONT COLOR=#115511>'.'</FONT>)
    <FONT COLOR=#3333CC><B>if</B></FONT> build:
        l.append(build)
    <FONT COLOR=#3333CC><B>try</B></FONT>:
        ints = map(int,l)
    <FONT COLOR=#3333CC><B>except</B></FONT> ValueError:
        strings = l
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        strings = map(str,ints)
    version = string.join(strings[:3],<FONT COLOR=#115511>'.'</FONT>)
    <FONT COLOR=#3333CC><B>return</B></FONT> version

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="_syscmd_ver"><FONT COLOR=#CC0000><B> _syscmd_ver</B></FONT></A>(system=<FONT COLOR=#115511>''</FONT>,release=<FONT COLOR=#115511>''</FONT>,version=<FONT COLOR=#115511>''</FONT>,

               supported_platforms=(<FONT COLOR=#115511>'win32'</FONT>,<FONT COLOR=#115511>'win16'</FONT>,<FONT COLOR=#115511>'dos'</FONT>,<FONT COLOR=#115511>'os2'</FONT>),
               ver_output=re.compile(<FONT COLOR=#115511>'(?:([\w ]+) ([\w.]+) '</FONT>
                                     <FONT COLOR=#115511>'.*'</FONT>
                                     <FONT COLOR=#115511>'Version ([\d.]+))'</FONT>)):

    <FONT COLOR=#115511>""" Tries to figure out the OS version used and returns
        a tuple (system,release,version).
        
        It uses the "ver" shell command for this which is known
        to exists on Windows, DOS and OS/2. XXX Others too ?

        In case this fails, the given parameters are used as
        defaults.

    """</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> sys.platform <FONT COLOR=#3333CC><B>not</B></FONT> <FONT COLOR=#3333CC><B>in</B></FONT> supported_platforms:
        <FONT COLOR=#3333CC><B>return</B></FONT> system,release,version

    <FONT COLOR=#1111CC># Find a working popen implementation preferring win32pipe.popen</FONT>
    <FONT COLOR=#1111CC># over os.popen over _popen</FONT>
    popen = None
    <FONT COLOR=#3333CC><B>if</B></FONT> os.environ.get(<FONT COLOR=#115511>'OS'</FONT>,<FONT COLOR=#115511>''</FONT>) == <FONT COLOR=#115511>'Windows_NT'</FONT>:
        <FONT COLOR=#1111CC># On NT win32pipe should work; on Win9x it hangs due to bugs</FONT>
        <FONT COLOR=#1111CC># in the MS C lib (see MS KnowledgeBase article Q150956)</FONT>
        <FONT COLOR=#3333CC><B>try</B></FONT>:
            <FONT COLOR=#3333CC><B>import</B></FONT> win32pipe
        <FONT COLOR=#3333CC><B>except</B></FONT> ImportError:
            <FONT COLOR=#3333CC><B>pass</B></FONT>
        <FONT COLOR=#3333CC><B>else</B></FONT>:
            popen = win32pipe.popen
    <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> popen:
        <FONT COLOR=#3333CC><B>if</B></FONT> hasattr(os,<FONT COLOR=#115511>'popen'</FONT>):
            popen = os.popen
            <FONT COLOR=#1111CC># Check whether it works... it doesn't in GUI programs</FONT>
            <FONT COLOR=#1111CC># on Windows platforms</FONT>
            <FONT COLOR=#3333CC><B>if</B></FONT> sys.platform == <FONT COLOR=#115511>'win32'</FONT>: <FONT COLOR=#1111CC># XXX Others too ?</FONT>
                <FONT COLOR=#3333CC><B>try</B></FONT>:
                    popen(<FONT COLOR=#115511>''</FONT>)
                <FONT COLOR=#3333CC><B>except</B></FONT> os.error:
                    popen = _popen
        <FONT COLOR=#3333CC><B>else</B></FONT>:
            popen = _popen

    <FONT COLOR=#1111CC># Try some common cmd strings</FONT>
    <FONT COLOR=#3333CC><B>for</B></FONT> cmd <FONT COLOR=#3333CC><B>in</B></FONT> (<FONT COLOR=#115511>'ver'</FONT>,<FONT COLOR=#115511>'command /c ver'</FONT>,<FONT COLOR=#115511>'cmd /c ver'</FONT>):
        <FONT COLOR=#3333CC><B>try</B></FONT>:
            pipe = popen(cmd)
            info = pipe.read()
            <FONT COLOR=#3333CC><B>if</B></FONT> pipe.close():
                <FONT COLOR=#3333CC><B>raise</B></FONT> os.error,<FONT COLOR=#115511>'command failed'</FONT>
            <FONT COLOR=#1111CC># XXX How can I supress shell errors from being written</FONT>
            <FONT COLOR=#1111CC>#     to stderr ?</FONT>
        <FONT COLOR=#3333CC><B>except</B></FONT> os.error,why:
            <FONT COLOR=#1111CC>#print </FONT><FONT COLOR=#115511>'Command %s failed: %s'</FONT> % (cmd,why)
            <FONT COLOR=#3333CC><B>continue</B></FONT>
        <FONT COLOR=#3333CC><B>except</B></FONT> IOError,why:
            <FONT COLOR=#1111CC>#print </FONT><FONT COLOR=#115511>'Command %s failed: %s'</FONT> % (cmd,why)
            <FONT COLOR=#3333CC><B>continue</B></FONT>
        <FONT COLOR=#3333CC><B>else</B></FONT>:
            <FONT COLOR=#3333CC><B>break</B></FONT>
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        <FONT COLOR=#3333CC><B>return</B></FONT> system,release,version

    <FONT COLOR=#1111CC># Parse the output</FONT>
    info = string.strip(info)
    m = ver_output.match(info)
    <FONT COLOR=#3333CC><B>if</B></FONT> m:
        system,release,version = m.groups()
        <FONT COLOR=#1111CC># Strip trailing dots from version and release</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> release[-1] == <FONT COLOR=#115511>'.'</FONT>:
            release = release[:-1]
        <FONT COLOR=#3333CC><B>if</B></FONT> version[-1] == <FONT COLOR=#115511>'.'</FONT>:
            version = version[:-1]
        <FONT COLOR=#1111CC># Normalize the version and build strings (eliminating additional</FONT>
        <FONT COLOR=#1111CC># zeros)</FONT>
        version = _norm_version(version)
    <FONT COLOR=#3333CC><B>return</B></FONT> system,release,version

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="_win32_getvalue"><FONT COLOR=#CC0000><B> _win32_getvalue</B></FONT></A>(key,name,default=<FONT COLOR=#115511>''</FONT>):

    <FONT COLOR=#115511>""" Read a value for name from the registry key.

        In case this fails, default is returned.

    """</FONT>
    <FONT COLOR=#3333CC><B>from</B></FONT> win32api <FONT COLOR=#3333CC><B>import</B></FONT> RegQueryValueEx
    <FONT COLOR=#3333CC><B>try</B></FONT>:
        <FONT COLOR=#3333CC><B>return</B></FONT> RegQueryValueEx(key,name)
    <FONT COLOR=#3333CC><B>except</B></FONT>:
        <FONT COLOR=#3333CC><B>return</B></FONT> default

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="win32_ver"><FONT COLOR=#CC0000><B> win32_ver</B></FONT></A>(release=<FONT COLOR=#115511>''</FONT>,version=<FONT COLOR=#115511>''</FONT>,csd=<FONT COLOR=#115511>''</FONT>,ptype=<FONT COLOR=#115511>''</FONT>):

    <FONT COLOR=#115511>""" Get additional version information from the Windows Registry
        and return a tuple (version,csd,ptype) referring to version
        number, CSD level and OS type (multi/single
        processor).

        As a hint: ptype returns 'Uniprocessor Free' on single
        processor NT machines and 'Multiprocessor Free' on multi
        processor machines. The 'Free' refers to the OS version being
        free of debugging code. It could also state 'Checked' which
        means the OS version uses debugging code, i.e. code that
        checks arguments, ranges, etc. (Thomas Heller).

        Note: this functions only works if Mark Hammond's win32
        package is installed and obviously only runs on Win32
        compatible platforms.

        XXX Is there any way to find out the processor type on WinXX ?

        XXX Is win32 available on Windows CE ?

        Adapted from code posted by Karl Putland to comp.lang.python.

    """</FONT>
    <FONT COLOR=#1111CC># Import the needed APIs</FONT>
    <FONT COLOR=#3333CC><B>try</B></FONT>:
        <FONT COLOR=#3333CC><B>import</B></FONT> win32api
    <FONT COLOR=#3333CC><B>except</B></FONT> ImportError:
        <FONT COLOR=#3333CC><B>return</B></FONT> release,version,csd,ptype
    <FONT COLOR=#3333CC><B>from</B></FONT> win32api <FONT COLOR=#3333CC><B>import</B></FONT> RegQueryValueEx,RegOpenKeyEx,RegCloseKey,GetVersionEx
    <FONT COLOR=#3333CC><B>from</B></FONT> win32con <FONT COLOR=#3333CC><B>import</B></FONT> HKEY_LOCAL_MACHINE,VER_PLATFORM_WIN32_NT,\
                         VER_PLATFORM_WIN32_WINDOWS

    <FONT COLOR=#1111CC># Find out the registry key and some general version infos</FONT>
    maj,min,buildno,plat,csd = GetVersionEx()
    version = <FONT COLOR=#115511>'%i.%i.%i'</FONT> % (maj,min,buildno & 0xFFFF)
    <FONT COLOR=#3333CC><B>if</B></FONT> csd[:13] == <FONT COLOR=#115511>'Service Pack '</FONT>:
        csd = <FONT COLOR=#115511>'SP'</FONT> + csd[13:]
    <FONT COLOR=#3333CC><B>if</B></FONT> plat == VER_PLATFORM_WIN32_WINDOWS:
        regkey = <FONT COLOR=#115511>'SOFTWARE\\Microsoft\\Windows\\CurrentVersion'</FONT>
        <FONT COLOR=#1111CC># Try to guess the release name</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> maj == 4:
            <FONT COLOR=#3333CC><B>if</B></FONT> min == 0:
                release = <FONT COLOR=#115511>'95'</FONT>
            <FONT COLOR=#3333CC><B>else</B></FONT>:
                release = <FONT COLOR=#115511>'98'</FONT>
        <FONT COLOR=#3333CC><B>elif</B></FONT> maj == 5:
            release = <FONT COLOR=#115511>'2000'</FONT>
    <FONT COLOR=#3333CC><B>elif</B></FONT> plat == VER_PLATFORM_WIN32_NT:
        regkey = <FONT COLOR=#115511>'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion'</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> maj &lt;= 4:
            release = <FONT COLOR=#115511>'NT'</FONT>
        <FONT COLOR=#3333CC><B>elif</B></FONT> maj == 5:
            release = <FONT COLOR=#115511>'2000'</FONT>
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> release:
            <FONT COLOR=#1111CC># E.g. Win3.1 with win32s</FONT>
            release = <FONT COLOR=#115511>'%i.%i'</FONT> % (maj,min)
        <FONT COLOR=#3333CC><B>return</B></FONT> release,version,csd,ptype

    <FONT COLOR=#1111CC># Open the registry key</FONT>
    <FONT COLOR=#3333CC><B>try</B></FONT>:
        keyCurVer = RegOpenKeyEx(HKEY_LOCAL_MACHINE,regkey)
        <FONT COLOR=#1111CC># Get a value to make sure the key exists...</FONT>
        RegQueryValueEx(keyCurVer,<FONT COLOR=#115511>'SystemRoot'</FONT>)
    <FONT COLOR=#3333CC><B>except</B></FONT>:
        <FONT COLOR=#3333CC><B>return</B></FONT> release,version,csd,ptype
    
    <FONT COLOR=#1111CC># Parse values</FONT>
    <FONT COLOR=#1111CC>#subversion = _win32_getvalue(keyCurVer,</FONT>
    <FONT COLOR=#1111CC>#                            'SubVersionNumber',</FONT>
    <FONT COLOR=#1111CC>#                            ('',1))[0]</FONT>
    <FONT COLOR=#1111CC>#if </FONT>subversion:
    <FONT COLOR=#1111CC>#   release = release + subversion # 95a, 95b, etc.</FONT>
    build = _win32_getvalue(keyCurVer,
                            <FONT COLOR=#115511>'CurrentBuildNumber'</FONT>,
                            (<FONT COLOR=#115511>''</FONT>,1))[0]
    ptype = _win32_getvalue(keyCurVer,
                           <FONT COLOR=#115511>'CurrentType'</FONT>,
                           (ptype,1))[0]

    <FONT COLOR=#1111CC># Normalize version</FONT>
    version = _norm_version(version,build)

    <FONT COLOR=#1111CC># Close key</FONT>
    RegCloseKey(keyCurVer)
    <FONT COLOR=#3333CC><B>return</B></FONT> release,version,csd,ptype

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="_mac_ver_lookup"><FONT COLOR=#CC0000><B> _mac_ver_lookup</B></FONT></A>(selectors,default=None):

    <FONT COLOR=#3333CC><B>from</B></FONT> gestalt <FONT COLOR=#3333CC><B>import</B></FONT> gestalt
    l = []
    append = l.append
    <FONT COLOR=#3333CC><B>for</B></FONT> selector <FONT COLOR=#3333CC><B>in</B></FONT> selectors:
        <FONT COLOR=#3333CC><B>try</B></FONT>:
            append(gestalt(selector))
        <FONT COLOR=#3333CC><B>except</B></FONT> RuntimeError:
            append(default)
    <FONT COLOR=#3333CC><B>return</B></FONT> l

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="_bcd2str"><FONT COLOR=#CC0000><B> _bcd2str</B></FONT></A>(bcd):

    <FONT COLOR=#3333CC><B>return</B></FONT> hex(bcd)[2:]

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="mac_ver"><FONT COLOR=#CC0000><B> mac_ver</B></FONT></A>(release=<FONT COLOR=#115511>''</FONT>,versioninfo=(<FONT COLOR=#115511>''</FONT>,<FONT COLOR=#115511>''</FONT>,<FONT COLOR=#115511>''</FONT>),machine=<FONT COLOR=#115511>''</FONT>):

    <FONT COLOR=#115511>""" Get MacOS version information and return it as tuple (release,
        versioninfo, machine) with versioninfo being a tuple (version,
        dev_stage, non_release_version).

        Entries which cannot be determined are set to ''. All tuple
        entries are strings.

        Thanks to Mark R. Levinson for mailing documentation links and
        code examples for this function. Documentation for the
        gestalt() API is available online at:

           http://www.rgaros.nl/gestalt/

    """</FONT>
    <FONT COLOR=#1111CC># Check whether the version info module is available</FONT>
    <FONT COLOR=#3333CC><B>try</B></FONT>:
        <FONT COLOR=#3333CC><B>import</B></FONT> gestalt
    <FONT COLOR=#3333CC><B>except</B></FONT> ImportError:
        <FONT COLOR=#3333CC><B>return</B></FONT> release,versioninfo,machine
    <FONT COLOR=#1111CC># Get the infos</FONT>
    sysv,sysu,sysa = _mac_ver_lookup((<FONT COLOR=#115511>'sysv'</FONT>,<FONT COLOR=#115511>'sysu'</FONT>,<FONT COLOR=#115511>'sysa'</FONT>))
    <FONT COLOR=#1111CC># Decode the infos</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> sysv:
        major = (sysv & 0xFF00) &gt;&gt; 8
        minor = (sysv & 0x00F0) &gt;&gt; 4
        patch = (sysv & 0x000F)
        release = <FONT COLOR=#115511>'%s.%i.%i'</FONT> % (_bcd2str(major),minor,patch)
    <FONT COLOR=#3333CC><B>if</B></FONT> sysu:
        major =  (sysu & 0xFF000000) &gt;&gt; 24
        minor =  (sysu & 0x00F00000) &gt;&gt; 20
        bugfix = (sysu & 0x000F0000) &gt;&gt; 16
        stage =  (sysu & 0x0000FF00) &gt;&gt; 8
        nonrel = (sysu & 0x000000FF)
        version = <FONT COLOR=#115511>'%s.%i.%i'</FONT> % (_bcd2str(major),minor,bugfix)
        nonrel = _bcd2str(nonrel)
        stage = {0x20:<FONT COLOR=#115511>'development'</FONT>,
                 0x40:<FONT COLOR=#115511>'alpha'</FONT>,
                 0x60:<FONT COLOR=#115511>'beta'</FONT>,
                 0x80:<FONT COLOR=#115511>'final'</FONT>}.get(stage,<FONT COLOR=#115511>''</FONT>)
        versioninfo = (version,stage,nonrel)
    <FONT COLOR=#3333CC><B>if</B></FONT> sysa:
        machine = {0x1: <FONT COLOR=#115511>'68k'</FONT>, 
                   0x2: <FONT COLOR=#115511>'PowerPC'</FONT>}.get(sysa,<FONT COLOR=#115511>''</FONT>)
    <FONT COLOR=#3333CC><B>return</B></FONT> release,versioninfo,machine

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="_java_getprop"><FONT COLOR=#CC0000><B> _java_getprop</B></FONT></A>(self,name,default):

    <FONT COLOR=#3333CC><B>from</B></FONT> java.lang <FONT COLOR=#3333CC><B>import</B></FONT> System
    <FONT COLOR=#3333CC><B>try</B></FONT>:
        <FONT COLOR=#3333CC><B>return</B></FONT> System.getProperty(name)
    <FONT COLOR=#3333CC><B>except</B></FONT>:
        <FONT COLOR=#3333CC><B>return</B></FONT> default

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="java_ver"><FONT COLOR=#CC0000><B> java_ver</B></FONT></A>(release=<FONT COLOR=#115511>''</FONT>,vendor=<FONT COLOR=#115511>''</FONT>,vminfo=(<FONT COLOR=#115511>''</FONT>,<FONT COLOR=#115511>''</FONT>,<FONT COLOR=#115511>''</FONT>),osinfo=(<FONT COLOR=#115511>''</FONT>,<FONT COLOR=#115511>''</FONT>,<FONT COLOR=#115511>''</FONT>)):
    
    <FONT COLOR=#115511>""" Version interface for JPython.

        Returns a tuple (release,vendor,vminfo,osinfo) with vminfo being
        a tuple (vm_name,vm_release,vm_vendor) and osinfo being a
        tuple (os_name,os_version,os_arch).

        Values which cannot be determined are set to the defaults
        given as parameters (which all default to '').

    """</FONT>
    <FONT COLOR=#1111CC># Import the needed APIs</FONT>
    <FONT COLOR=#3333CC><B>try</B></FONT>:
        <FONT COLOR=#3333CC><B>import</B></FONT> java.lang
    <FONT COLOR=#3333CC><B>except</B></FONT> ImportError:
        <FONT COLOR=#3333CC><B>return</B></FONT> release,vendor,vminfo,osinfo

    vendor = _java_getprop(<FONT COLOR=#115511>'java.vendor'</FONT>,vendor)
    release = _java_getprop(<FONT COLOR=#115511>'java.version'</FONT>,release)
    vm_name,vm_release,vm_vendor = vminfo
    vm_name = _java_getprop(<FONT COLOR=#115511>'java.vm.name'</FONT>,vm_name)
    vm_vendor = _java_getprop(<FONT COLOR=#115511>'java.vm.vendor'</FONT>,vm_vendor)
    vm_release = _java_getprop(<FONT COLOR=#115511>'java.vm.version'</FONT>,vm_release)
    vminfo = vm_name,vm_release,vm_vendor
    os_name,os_version,os_arch = osinfo
    os_arch = _java_getprop(<FONT COLOR=#115511>'java.os.arch'</FONT>,os_arch)
    os_name = _java_getprop(<FONT COLOR=#115511>'java.os.name'</FONT>,os_name)
    os_version = _java_getprop(<FONT COLOR=#115511>'java.os.version'</FONT>,os_version)
    osinfo = os_name,os_version,os_arch
    
    <FONT COLOR=#3333CC><B>return</B></FONT> release,vendor,vminfo,osinfo

<FONT COLOR=#1111CC>### System name aliasing</FONT>

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="system_alias"><FONT COLOR=#CC0000><B> system_alias</B></FONT></A>(system,release,version):

    <FONT COLOR=#115511>""" Returns (system,release,version) aliased to common
        marketing names used for some systems.

        It also does some reordering of the information in some cases
        where it would otherwise cause confusion.

    """</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> system == <FONT COLOR=#115511>'Rhapsody'</FONT>:
        <FONT COLOR=#1111CC># Apple's BSD derivative</FONT>
        <FONT COLOR=#1111CC># XXX How can we determine the marketing release number ?</FONT>
        <FONT COLOR=#3333CC><B>return</B></FONT> <FONT COLOR=#115511>'MacOS X Server'</FONT>,system+release,version

    <FONT COLOR=#3333CC><B>elif</B></FONT> system == <FONT COLOR=#115511>'SunOS'</FONT>:
        <FONT COLOR=#1111CC># Sun's OS</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> release &lt; <FONT COLOR=#115511>'5'</FONT>:
            <FONT COLOR=#1111CC># These releases use the old name SunOS</FONT>
            <FONT COLOR=#3333CC><B>return</B></FONT> system,release,version
        <FONT COLOR=#1111CC># Modify release (marketing release = SunOS release - 3)</FONT>
        l = string.split(release,<FONT COLOR=#115511>'.'</FONT>)
        <FONT COLOR=#3333CC><B>if</B></FONT> l:
            <FONT COLOR=#3333CC><B>try</B></FONT>:
                major = int(l[0])
            <FONT COLOR=#3333CC><B>except</B></FONT> ValueError:
                <FONT COLOR=#3333CC><B>pass</B></FONT>
            <FONT COLOR=#3333CC><B>else</B></FONT>:
                major = major - 3
                l[0] = str(major)
                release = string.join(l,<FONT COLOR=#115511>'.'</FONT>)
        <FONT COLOR=#3333CC><B>if</B></FONT> release &lt; <FONT COLOR=#115511>'6'</FONT>:
            system = <FONT COLOR=#115511>'Solaris'</FONT>
        <FONT COLOR=#3333CC><B>else</B></FONT>:
            <FONT COLOR=#1111CC># XXX Whatever the new SunOS marketing name is...</FONT>
            system = <FONT COLOR=#115511>'Solaris'</FONT>

    <FONT COLOR=#3333CC><B>elif</B></FONT> system == <FONT COLOR=#115511>'IRIX64'</FONT>:
        <FONT COLOR=#1111CC># IRIX reports IRIX64 on platforms with 64-bit support; yet it</FONT>
        <FONT COLOR=#1111CC># is really a version and not a different platform, since 32-bit</FONT>
        <FONT COLOR=#1111CC># apps are also supported..</FONT>
        system = <FONT COLOR=#115511>'IRIX'</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> version:
            version = version + <FONT COLOR=#115511>' (64bit)'</FONT>
        <FONT COLOR=#3333CC><B>else</B></FONT>:
            version = <FONT COLOR=#115511>'64bit'</FONT>

    <FONT COLOR=#3333CC><B>elif</B></FONT> system <FONT COLOR=#3333CC><B>in</B></FONT> (<FONT COLOR=#115511>'win32'</FONT>,<FONT COLOR=#115511>'win16'</FONT>):
        <FONT COLOR=#1111CC># In case one of the other tricks</FONT>
        system = <FONT COLOR=#115511>'Windows'</FONT>

    <FONT COLOR=#3333CC><B>return</B></FONT> system,release,version

<FONT COLOR=#1111CC>### Various internal helpers</FONT>

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="_platform"><FONT COLOR=#CC0000><B> _platform</B></FONT></A>(*args):

    <FONT COLOR=#115511>""" Helper to format the platform string in a filename
        compatible format e.g. "system-version-machine".
    """</FONT>
    <FONT COLOR=#1111CC># Format the platform string</FONT>
    platform = string.join(
        map(string.strip,
            filter(len,args)),
        <FONT COLOR=#115511>'-'</FONT>)

    <FONT COLOR=#1111CC># Cleanup some possible filename obstacles...</FONT>
    replace = string.replace
    platform = replace(platform,<FONT COLOR=#115511>' '</FONT>,<FONT COLOR=#115511>'_'</FONT>)
    platform = replace(platform,<FONT COLOR=#115511>'/'</FONT>,<FONT COLOR=#115511>'-'</FONT>)
    platform = replace(platform,<FONT COLOR=#115511>'\\'</FONT>,<FONT COLOR=#115511>'-'</FONT>)
    platform = replace(platform,<FONT COLOR=#115511>':'</FONT>,<FONT COLOR=#115511>'-'</FONT>)
    platform = replace(platform,<FONT COLOR=#115511>';'</FONT>,<FONT COLOR=#115511>'-'</FONT>)
    platform = replace(platform,<FONT COLOR=#115511>'"'</FONT>,<FONT COLOR=#115511>'-'</FONT>)
    platform = replace(platform,<FONT COLOR=#115511>'('</FONT>,<FONT COLOR=#115511>'-'</FONT>)
    platform = replace(platform,<FONT COLOR=#115511>')'</FONT>,<FONT COLOR=#115511>'-'</FONT>)

    <FONT COLOR=#1111CC># No need to report 'unkown' information...</FONT>
    platform = replace(platform,<FONT COLOR=#115511>'unknown'</FONT>,<FONT COLOR=#115511>''</FONT>)

    <FONT COLOR=#1111CC># Fold '--'s and remove trailing '-'</FONT>
    <FONT COLOR=#3333CC><B>while</B></FONT> 1:
        cleaned = replace(platform,<FONT COLOR=#115511>'--'</FONT>,<FONT COLOR=#115511>'-'</FONT>)
        <FONT COLOR=#3333CC><B>if</B></FONT> cleaned == platform:
            <FONT COLOR=#3333CC><B>break</B></FONT>
        platform = cleaned
    <FONT COLOR=#3333CC><B>while</B></FONT> platform[-1] == <FONT COLOR=#115511>'-'</FONT>:
        platform = platform[:-1]

    <FONT COLOR=#3333CC><B>return</B></FONT> platform

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="_node"><FONT COLOR=#CC0000><B> _node</B></FONT></A>(default=<FONT COLOR=#115511>''</FONT>):

    <FONT COLOR=#115511>""" Helper to determine the node name of this machine.
    """</FONT>
    <FONT COLOR=#3333CC><B>try</B></FONT>:
        <FONT COLOR=#3333CC><B>import</B></FONT> socket
    <FONT COLOR=#3333CC><B>except</B></FONT> ImportError:
        <FONT COLOR=#1111CC># No sockets...</FONT>
        <FONT COLOR=#3333CC><B>return</B></FONT> default
    <FONT COLOR=#3333CC><B>try</B></FONT>:
        <FONT COLOR=#3333CC><B>return</B></FONT> socket.gethostname()
    <FONT COLOR=#3333CC><B>except</B></FONT> socket.error:
        <FONT COLOR=#1111CC># Still not working...</FONT>
        <FONT COLOR=#3333CC><B>return</B></FONT> default

<FONT COLOR=#1111CC># os.path.abspath is new in Python 1.5.2:</FONT>
<FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> hasattr(os.path,<FONT COLOR=#115511>'abspath'</FONT>):

    <FONT COLOR=#3333CC><B>def</B></FONT><A NAME="_abspath"><FONT COLOR=#CC0000><B> _abspath</B></FONT></A>(path,

                 isabs=os.path.isabs,join=os.path.join,getcwd=os.getcwd,
                 normpath=os.path.normpath):

        <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> isabs(path):
            path = join(getcwd(), path)
        <FONT COLOR=#3333CC><B>return</B></FONT> normpath(path)

<FONT COLOR=#3333CC><B>else</B></FONT>:

    _abspath = os.path.abspath

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="_follow_symlinks"><FONT COLOR=#CC0000><B> _follow_symlinks</B></FONT></A>(filepath):

    <FONT COLOR=#115511>""" In case filepath is a symlink, follow it until a
        real file is reached.
    """</FONT>
    filepath = _abspath(filepath)
    <FONT COLOR=#3333CC><B>while</B></FONT> os.path.islink(filepath):
        filepath = os.path.normpath(
            os.path.join(filepath,os.readlink(filepath)))
    <FONT COLOR=#3333CC><B>return</B></FONT> filepath

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="_syscmd_uname"><FONT COLOR=#CC0000><B> _syscmd_uname</B></FONT></A>(option,default=<FONT COLOR=#115511>''</FONT>):

    <FONT COLOR=#115511>""" Interface to the system's uname command.
    """</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> sys.platform <FONT COLOR=#3333CC><B>in</B></FONT> (<FONT COLOR=#115511>'dos'</FONT>,<FONT COLOR=#115511>'win32'</FONT>,<FONT COLOR=#115511>'win16'</FONT>,<FONT COLOR=#115511>'os2'</FONT>):
        <FONT COLOR=#1111CC># XXX Others too ?</FONT>
        <FONT COLOR=#3333CC><B>return</B></FONT> default
    <FONT COLOR=#3333CC><B>try</B></FONT>:
        f = os.popen(<FONT COLOR=#115511>'uname %s 2&gt; /dev/null'</FONT> % option)
    <FONT COLOR=#3333CC><B>except</B></FONT> (AttributeError,os.error):
        <FONT COLOR=#3333CC><B>return</B></FONT> default
    output = string.strip(f.read())
    rc = f.close()
    <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> output <FONT COLOR=#3333CC><B>or</B></FONT> rc:
        <FONT COLOR=#3333CC><B>return</B></FONT> default
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        <FONT COLOR=#3333CC><B>return</B></FONT> output

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="_syscmd_file"><FONT COLOR=#CC0000><B> _syscmd_file</B></FONT></A>(target,default=<FONT COLOR=#115511>''</FONT>):

    <FONT COLOR=#115511>""" Interface to the system's file command.

        The function uses the -b option of the file command to have it
        ommit the filename in its output and if possible the -L option
        to have the command follow symlinks. It returns default in
        case the command should fail.

    """</FONT>
    target = _follow_symlinks(target)
    <FONT COLOR=#3333CC><B>try</B></FONT>:
        f = os.popen(<FONT COLOR=#115511>'file %s 2&gt; /dev/null'</FONT> % target)
    <FONT COLOR=#3333CC><B>except</B></FONT> (AttributeError,os.error):
        <FONT COLOR=#3333CC><B>return</B></FONT> default
    output = string.strip(f.read())
    rc = f.close()
    <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> output <FONT COLOR=#3333CC><B>or</B></FONT> rc:
        <FONT COLOR=#3333CC><B>return</B></FONT> default
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        <FONT COLOR=#3333CC><B>return</B></FONT> output

<FONT COLOR=#1111CC>### Information about the used architecture</FONT>

<FONT COLOR=#1111CC># Default values for architecture; non-empty strings override the</FONT>
<FONT COLOR=#1111CC># defaults given as parameters</FONT>
_default_architecture = {
    <FONT COLOR=#115511>'win32'</FONT>: (<FONT COLOR=#115511>''</FONT>,<FONT COLOR=#115511>'WindowsPE'</FONT>),
    <FONT COLOR=#115511>'win16'</FONT>: (<FONT COLOR=#115511>''</FONT>,<FONT COLOR=#115511>'Windows'</FONT>),
    <FONT COLOR=#115511>'dos'</FONT>: (<FONT COLOR=#115511>''</FONT>,<FONT COLOR=#115511>'MSDOS'</FONT>),
}

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="architecture"><FONT COLOR=#CC0000><B> architecture</B></FONT></A>(executable=sys.executable,bits=<FONT COLOR=#115511>''</FONT>,linkage=<FONT COLOR=#115511>''</FONT>,

                 split=re.compile(<FONT COLOR=#115511>'[\s,]'</FONT>).split):

    <FONT COLOR=#115511>""" Queries the given executable (defaults to the Python interpreter
        binary) for various architecture informations.

        Returns a tuple (bits,linkage) which contain information about
        the bit architecture and the linkage format used for the
        executable. Both values are returned as strings.

        Values that cannot be determined are returned as given by the
        parameter presets. If bits is given as '', the sizeof(long) is
        used as indicator for the supported pointer size.

        The function relies on the system's "file" command to do the
        actual work. This is available on most if not all Unix
        platforms. On some non-Unix platforms and then only if the
        executable points to the Python interpreter defaults from
        _default_architecture are used.

    """</FONT>
    <FONT COLOR=#1111CC># Use the sizeof(long) as default number of bits if nothing</FONT>
    <FONT COLOR=#1111CC># else is given as default.</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> bits:
        <FONT COLOR=#3333CC><B>import</B></FONT> struct
        bits = str(struct.calcsize(<FONT COLOR=#115511>'l'</FONT>)*8) + <FONT COLOR=#115511>'bit'</FONT>
    
    <FONT COLOR=#1111CC># Get data from the 'file' system command</FONT>
    output = _syscmd_file(executable,<FONT COLOR=#115511>''</FONT>)

    <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> output <FONT COLOR=#3333CC><B>and</B></FONT> executable == sys.executable:
        <FONT COLOR=#1111CC># "file" command did not return anything; we'll try to provide</FONT>
        <FONT COLOR=#1111CC># some sensible defaults then... </FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> _default_architecture.has_key(sys.platform):
            b,l = _default_architecture[sys.platform]
            <FONT COLOR=#3333CC><B>if</B></FONT> b:
                bits = b
            <FONT COLOR=#3333CC><B>if</B></FONT> l:
                linkage = l
        <FONT COLOR=#3333CC><B>return</B></FONT> bits,linkage

    <FONT COLOR=#1111CC># Split the output into a list of strings omitting the filename</FONT>
    fileout = split(output)[1:]
    
    <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#115511>'executable'</FONT> <FONT COLOR=#3333CC><B>not</B></FONT> <FONT COLOR=#3333CC><B>in</B></FONT> fileout:
        <FONT COLOR=#1111CC># Format not supported</FONT>
        <FONT COLOR=#3333CC><B>return</B></FONT> bits,linkage

    <FONT COLOR=#1111CC># Bits</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#115511>'32-bit'</FONT> <FONT COLOR=#3333CC><B>in</B></FONT> fileout:
        bits = <FONT COLOR=#115511>'32bit'</FONT>
    <FONT COLOR=#3333CC><B>elif</B></FONT> <FONT COLOR=#115511>'N32'</FONT> <FONT COLOR=#3333CC><B>in</B></FONT> fileout:
        <FONT COLOR=#1111CC># On Irix only</FONT>
        bits = <FONT COLOR=#115511>'n32bit'</FONT>
    <FONT COLOR=#3333CC><B>elif</B></FONT> <FONT COLOR=#115511>'64-bit'</FONT> <FONT COLOR=#3333CC><B>in</B></FONT> fileout:
        bits = <FONT COLOR=#115511>'64bit'</FONT>

    <FONT COLOR=#1111CC># Linkage</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#115511>'ELF'</FONT> <FONT COLOR=#3333CC><B>in</B></FONT> fileout:
        linkage = <FONT COLOR=#115511>'ELF'</FONT>
    <FONT COLOR=#3333CC><B>elif</B></FONT> <FONT COLOR=#115511>'PE'</FONT> <FONT COLOR=#3333CC><B>in</B></FONT> fileout:
        <FONT COLOR=#1111CC># E.g. Windows uses this format</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#115511>'Windows'</FONT> <FONT COLOR=#3333CC><B>in</B></FONT> fileout:
            linkage = <FONT COLOR=#115511>'WindowsPE'</FONT>
        <FONT COLOR=#3333CC><B>else</B></FONT>:
            linkage = <FONT COLOR=#115511>'PE'</FONT>
    <FONT COLOR=#3333CC><B>elif</B></FONT> <FONT COLOR=#115511>'COFF'</FONT> <FONT COLOR=#3333CC><B>in</B></FONT> fileout:
        linkage = <FONT COLOR=#115511>'COFF'</FONT>
    <FONT COLOR=#3333CC><B>elif</B></FONT> <FONT COLOR=#115511>'MS-DOS'</FONT> <FONT COLOR=#3333CC><B>in</B></FONT> fileout:
        linkage = <FONT COLOR=#115511>'MSDOS'</FONT>
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        <FONT COLOR=#1111CC># XXX the A.OUT format also falls under this class...</FONT>
        <FONT COLOR=#3333CC><B>pass</B></FONT>

    <FONT COLOR=#3333CC><B>return</B></FONT> bits,linkage

<FONT COLOR=#1111CC>### Portable uname() interface</FONT>
    
_uname_cache = None

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="uname"><FONT COLOR=#CC0000><B> uname</B></FONT></A>():

    <FONT COLOR=#115511>""" Fairly portable uname interface. Returns a tuple
        of strings (system,node,release,version,machine,processor)
        identifying the underlying platform.

        Note that unlike the os.uname function this also returns
        possible processor information as additional tuple entry.

        Entries which cannot be determined are set to ''.

    """</FONT>
    <FONT COLOR=#3333CC><B>global</B></FONT> _uname_cache

    <FONT COLOR=#3333CC><B>if</B></FONT> _uname_cache <FONT COLOR=#3333CC><B>is</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> None:
        <FONT COLOR=#3333CC><B>return</B></FONT> _uname_cache

    <FONT COLOR=#1111CC># Get some infos from the builtin os.uname API...</FONT>
    <FONT COLOR=#3333CC><B>try</B></FONT>:
        system,node,release,version,machine = os.uname()

    <FONT COLOR=#3333CC><B>except</B></FONT> AttributeError:
        <FONT COLOR=#1111CC># Hmm, no uname... we'll have to poke around the system then.</FONT>
        system = sys.platform
        release = <FONT COLOR=#115511>''</FONT>
        version = <FONT COLOR=#115511>''</FONT>
        node = _node()
        machine = <FONT COLOR=#115511>''</FONT>
        processor = <FONT COLOR=#115511>''</FONT>
        use_syscmd_ver = 1

        <FONT COLOR=#1111CC># Try win32_ver() on win32 platforms</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> system == <FONT COLOR=#115511>'win32'</FONT>:
            release,version,csd,ptype = win32_ver()
            <FONT COLOR=#3333CC><B>if</B></FONT> release <FONT COLOR=#3333CC><B>and</B></FONT> version:
                use_syscmd_ver = 0
        
        <FONT COLOR=#1111CC># Try the 'ver' system command available on some</FONT>
        <FONT COLOR=#1111CC># platforms</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> use_syscmd_ver:
            system,release,version = _syscmd_ver(system)

        <FONT COLOR=#1111CC># In case we still don't know anything useful, we'll try to</FONT>
        <FONT COLOR=#1111CC># help ourselves</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> system <FONT COLOR=#3333CC><B>in</B></FONT> (<FONT COLOR=#115511>'win32'</FONT>,<FONT COLOR=#115511>'win16'</FONT>):
            <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> version:
                <FONT COLOR=#3333CC><B>if</B></FONT> system == <FONT COLOR=#115511>'win32'</FONT>:
                    version = <FONT COLOR=#115511>'32bit'</FONT>
                <FONT COLOR=#3333CC><B>else</B></FONT>:
                    version = <FONT COLOR=#115511>'16bit'</FONT>
            system = <FONT COLOR=#115511>'Windows'</FONT>

        <FONT COLOR=#3333CC><B>elif</B></FONT> system[:4] == <FONT COLOR=#115511>'java'</FONT>:
            release,vendor,vminfo,osinfo = java_ver()
            system = <FONT COLOR=#115511>'Java'</FONT>
            version = string.join(vminfo,<FONT COLOR=#115511>', '</FONT>)
            <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> version:
                version = vendor

        <FONT COLOR=#3333CC><B>elif</B></FONT> os.name == <FONT COLOR=#115511>'mac'</FONT>:
            release,(version,stage,nonrel),machine = mac_ver()
            system = <FONT COLOR=#115511>'MacOS'</FONT>

    <FONT COLOR=#3333CC><B>else</B></FONT>:
        <FONT COLOR=#1111CC># System specific extensions</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> system == <FONT COLOR=#115511>'OpenVMS'</FONT>:
            <FONT COLOR=#1111CC># OpenVMS seems to have release and version mixed up</FONT>
            <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> release <FONT COLOR=#3333CC><B>or</B></FONT> release == <FONT COLOR=#115511>'0'</FONT>:
                release = version
                version = <FONT COLOR=#115511>''</FONT>
            <FONT COLOR=#1111CC># Get processor information</FONT>
            <FONT COLOR=#3333CC><B>try</B></FONT>:
                <FONT COLOR=#3333CC><B>import</B></FONT> vms_lib
            <FONT COLOR=#3333CC><B>except</B></FONT> ImportError:
                <FONT COLOR=#3333CC><B>pass</B></FONT>
            <FONT COLOR=#3333CC><B>else</B></FONT>:
                csid, cpu_number = vms_lib.getsyi(<FONT COLOR=#115511>'SYI$_CPU'</FONT>,0)
                <FONT COLOR=#3333CC><B>if</B></FONT> (cpu_number &gt;= 128):
                    processor = <FONT COLOR=#115511>'Alpha'</FONT>
                <FONT COLOR=#3333CC><B>else</B></FONT>:
                    processor = <FONT COLOR=#115511>'VAX'</FONT>
        <FONT COLOR=#3333CC><B>else</B></FONT>:
            <FONT COLOR=#1111CC># Get processor information from the uname system command</FONT>
            processor = _syscmd_uname(<FONT COLOR=#115511>'-p'</FONT>,<FONT COLOR=#115511>''</FONT>)

    <FONT COLOR=#1111CC># 'unkown' is not really any useful as information; we'll convert</FONT>
    <FONT COLOR=#1111CC># it to '' which is more portable</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> system == <FONT COLOR=#115511>'unknown'</FONT>:
        system = <FONT COLOR=#115511>''</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> node == <FONT COLOR=#115511>'unknown'</FONT>:
        node = <FONT COLOR=#115511>''</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> release == <FONT COLOR=#115511>'unknown'</FONT>:
        release = <FONT COLOR=#115511>''</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> version == <FONT COLOR=#115511>'unknown'</FONT>:
        version = <FONT COLOR=#115511>''</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> machine == <FONT COLOR=#115511>'unknown'</FONT>:
        machine = <FONT COLOR=#115511>''</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> processor == <FONT COLOR=#115511>'unknown'</FONT>:
        processor = <FONT COLOR=#115511>''</FONT>
    _uname_cache = system,node,release,version,machine,processor
    <FONT COLOR=#3333CC><B>return</B></FONT> _uname_cache

<FONT COLOR=#1111CC>### Direct interfaces to some of the uname() return values</FONT>

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="system"><FONT COLOR=#CC0000><B> system</B></FONT></A>():

    <FONT COLOR=#115511>""" Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.

        An empty string is returned if the value cannot be determined.

    """</FONT>
    <FONT COLOR=#3333CC><B>return</B></FONT> uname()[0]

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="node"><FONT COLOR=#CC0000><B> node</B></FONT></A>():

    <FONT COLOR=#115511>""" Returns the computer's network name (may not be fully qualified !)

        An empty string is returned if the value cannot be determined.

    """</FONT>
    <FONT COLOR=#3333CC><B>return</B></FONT> uname()[1]

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="release"><FONT COLOR=#CC0000><B> release</B></FONT></A>():

    <FONT COLOR=#115511>""" Returns the system's release, e.g. '2.2.0' or 'NT'

        An empty string is returned if the value cannot be determined.

    """</FONT>
    <FONT COLOR=#3333CC><B>return</B></FONT> uname()[2]

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="version"><FONT COLOR=#CC0000><B> version</B></FONT></A>():

    <FONT COLOR=#115511>""" Returns the system's release version, e.g. '#3 on degas'

        An empty string is returned if the value cannot be determined.

    """</FONT>
    <FONT COLOR=#3333CC><B>return</B></FONT> uname()[3]

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="machine"><FONT COLOR=#CC0000><B> machine</B></FONT></A>():

    <FONT COLOR=#115511>""" Returns the machine type, e.g. 'i386'

        An empty string is returned if the value cannot be determined.

    """</FONT>
    <FONT COLOR=#3333CC><B>return</B></FONT> uname()[4]

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="processor"><FONT COLOR=#CC0000><B> processor</B></FONT></A>():

    <FONT COLOR=#115511>""" Returns the (true) processor name, e.g. 'amdk6'

        An empty string is returned if the value cannot be
        determined. Note that many platforms do not provide this
        information or simply return the same value as for machine(),
        e.g.  NetBSD does this.

    """</FONT>
    <FONT COLOR=#3333CC><B>return</B></FONT> uname()[5]

<FONT COLOR=#1111CC>### The Opus Magnum of platform strings :-)</FONT>

_platform_cache = None
_platform_aliased_cache = None

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="platform"><FONT COLOR=#CC0000><B> platform</B></FONT></A>(aliased=0, terse=0):

    <FONT COLOR=#115511>""" Returns a single string identifying the underlying platform
        with as much useful information as possible (but no more :).
        
        The output is intended to be human readable rather than
        machine parseable. It may look different on different
        platforms and this is intended.

        If "aliased" is true, the function will use aliases for
        various platforms that report system names which differ from
        their common names, e.g. SunOS will be reported as
        Solaris. The system_alias() function is used to implement
        this.

        Setting terse to true causes the function to return only the
        absolute minimum information needed to identify the platform.

    """</FONT>
    <FONT COLOR=#3333CC><B>global</B></FONT> _platform_cache,_platform_aliased_cache

    <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> aliased <FONT COLOR=#3333CC><B>and</B></FONT> (_platform_cache <FONT COLOR=#3333CC><B>is</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> None):
        <FONT COLOR=#3333CC><B>return</B></FONT> _platform_cache
    <FONT COLOR=#3333CC><B>elif</B></FONT> _platform_aliased_cache <FONT COLOR=#3333CC><B>is</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> None:
        <FONT COLOR=#3333CC><B>return</B></FONT> _platform_aliased_cache

    <FONT COLOR=#1111CC># Get uname information and then apply platform specific cosmetics</FONT>
    <FONT COLOR=#1111CC># to it...</FONT>
    system,node,release,version,machine,processor = uname()
    <FONT COLOR=#3333CC><B>if</B></FONT> machine == processor:
        processor = <FONT COLOR=#115511>''</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> aliased:
        system,release,version = system_alias(system,release,version)

    <FONT COLOR=#3333CC><B>if</B></FONT> system == <FONT COLOR=#115511>'Windows'</FONT>:
        <FONT COLOR=#1111CC># MS platforms</FONT>
        rel,vers,csd,ptype = win32_ver(version)
        <FONT COLOR=#3333CC><B>if</B></FONT> terse:
            platform = _platform(system,release)
        <FONT COLOR=#3333CC><B>else</B></FONT>:
            platform = _platform(system,release,version,csd)

    <FONT COLOR=#3333CC><B>elif</B></FONT> system <FONT COLOR=#3333CC><B>in</B></FONT> (<FONT COLOR=#115511>'Linux'</FONT>,):
        <FONT COLOR=#1111CC># Linux based systems</FONT>
        distname,distversion,distid = dist(<FONT COLOR=#115511>''</FONT>)
        <FONT COLOR=#3333CC><B>if</B></FONT> terse:
            platform = _platform(system,release,machine)
        <FONT COLOR=#3333CC><B>elif</B></FONT> distname:
            platform = _platform(system,release,machine,processor,
                                 <FONT COLOR=#115511>'with'</FONT>,
                                 distname,distversion,distid)
        <FONT COLOR=#3333CC><B>else</B></FONT>:
            <FONT COLOR=#1111CC># If the distribution name is unknown check for libc vs. glibc</FONT>
            libcname,libcversion = libc_ver(sys.executable)
            platform = _platform(system,release,machine,processor,
                                 <FONT COLOR=#115511>'with'</FONT>,
                                 libcname+libcversion)
    <FONT COLOR=#3333CC><B>elif</B></FONT> system == <FONT COLOR=#115511>'Java'</FONT>:
        <FONT COLOR=#1111CC># Java platforms</FONT>
        r,v,vminfo,(os_name,os_version,os_arch) = java_ver()
        <FONT COLOR=#3333CC><B>if</B></FONT> terse:
            platform = _platform(system,release,version)
        <FONT COLOR=#3333CC><B>else</B></FONT>:
            platform = _platform(system,release,version,
                                 <FONT COLOR=#115511>'on'</FONT>,
                                 os_name,os_version,os_arch)

    <FONT COLOR=#3333CC><B>elif</B></FONT> system == <FONT COLOR=#115511>'MacOS'</FONT>:
        <FONT COLOR=#1111CC># MacOS platforms</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> terse:
            platform = _platform(system,release)
        <FONT COLOR=#3333CC><B>else</B></FONT>:
            platform = _platform(system,release,machine)

    <FONT COLOR=#3333CC><B>else</B></FONT>:
        <FONT COLOR=#1111CC># Generic handler</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> terse:
            platform = _platform(system,release)
        <FONT COLOR=#3333CC><B>else</B></FONT>:
            bits,linkage = architecture(sys.executable)
            platform = _platform(system,release,machine,processor,bits,linkage)
    
    <FONT COLOR=#3333CC><B>if</B></FONT> aliased:
        _platform_aliased_cache = platform
    <FONT COLOR=#3333CC><B>elif</B></FONT> terse:
        <FONT COLOR=#3333CC><B>pass</B></FONT>
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        _platform_cache = platform
    <FONT COLOR=#3333CC><B>return</B></FONT> platform

<FONT COLOR=#3333CC><B>if</B></FONT> __name__ == <FONT COLOR=#115511>'__main__'</FONT>:
    <FONT COLOR=#1111CC># Default is to print the aliased verbose platform string</FONT>
    terse = <FONT COLOR=#115511>'terse'</FONT> <FONT COLOR=#3333CC><B>in</B></FONT> sys.argv
    aliased = <FONT COLOR=#3333CC><B>not</B></FONT> <FONT COLOR=#115511>'nonaliased'</FONT> <FONT COLOR=#3333CC><B>in</B></FONT> sys.argv
    <FONT COLOR=#3333CC><B>print</B></FONT> platform(aliased,terse)
    sys.exit(0)
</PRE>
                  <!--footer-->
                  </BODY>
