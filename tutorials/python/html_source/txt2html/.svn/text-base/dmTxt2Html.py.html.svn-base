<HTML><HEAD><TITLE>/home/steder/PythonLectures/BobChat-v0.3/BobClient.py</TITLE></HEAD>
                  <BODY BGCOLOR=#FFFFFF>
                  <!--header-->
                  <!--script--><PRE>__oneliner__=<FONT COLOR=#115511>"Convert ASCII source files for HTML presentation"</FONT>
__longdoc__=<FONT COLOR=#115511>"""

  This program is not yet particularly smart, and will produce
  undefined output (or even traceback) if the source file does
  not meet expected format.  With time, it may get better about
  this.

      #------------------- Shell Usage -----------------------#
      Usage: python dmTxt2Html.py [options] [filename]    (or)
             txt2html.cgi [options] [filename]

          -h, /h, -?, /?, ?:   Show this help screen
          -type:&lt;type&gt;:        Set conversion type
                               (see discussion of types)
          -REBUILD_DOCS:       Generate 'txt2html.txt'
          -out:&lt;out&gt;:          Output filename (default STDOUT)
          -proxy:&lt;mode&gt;:       Use proxy element(s) in output
          &lt;STDIN&gt;, -, /:       Input from STDIN (default)

      Proxy modes are:  NAVIGATOR, TRAP_LINKS, ALL, NONE.
      Elements are "navigation bar" at top of pages and
      virtualization of in-page links.  Shell default in NONE.

      Note: CGI is detected by the absence of arguments;, if
            all defaults are wanted, specify STDIN explicitly:

          python txt2html.py - &lt; MyArticle.txt &gt; MyArticle.html
-
      #-------------------- CGI Usage ------------------------#
      Usage: A URL string may be composed manually, but the
             normal usage will be to call txt2html.cgi from an
             HTML form with the fields:  'source', 'preface,
             'type', 'proxy'.  'preface' allows explicit
             overriding of HTTP headers in the returned page,
             normally as a hidden field.  Use with caution (or
             don't use at all, the default is sensible).

      Example: &lt;form method="get" action="http://gnosis.cx/cgi-bin/txt2html.cgi"&gt;
               URL: &lt;input type="text" name="source" size=40&gt;
               &lt;input type="submit" name="go" value="Display!"&gt;&lt;/form&gt;

------------------------------------------------------------------------
Expected input format for [HTML]

  Source HTML is presented unmodified except for the inclusion
  of the Txt2HTML proxy at the top of each page.

Expected input format for [PYTHON]

   Source Python code is marked up with syntax highlighting, but
   no other HTML elements are introduced (no headers, no bold, no
   URLs, etc)

Expected input format for [SMART_ASCII]

      #--- Paragraph rules: ---#
      - Title occurs on first line of document, unindented and in
        all caps.
      - Subtitle occurs on second line, unindented and in mixed
        case.
      - Name, affiliation, date occur, unindented and in mixed
        case, on lines 4-6.
      - Section headings are preceded by two blank lines,
        unindented, in all caps, followed by one line of 72
        dashes and one blank line.
      - Regular text paragraphs are block style, and are indented
        two spaces.
      - Block quotations are indented four spaces, rather than
        the two of original text.
      - Code samples are indented six spaces (with internal
        indentation of code lines in the proper relative
        position).
      - Code samples may begin with a line indicating a title for
        that block.  If present, this title is indented the same
        six spaces as the rest of the block, and begins and ends
        with a pound sign ('#').  Dashes are used to fill space
        within the title for ASCII asthetics.
-
      #--- Character rules: ---#
      - All character markup has the pattern:
            whitespace-symbol-words(s)-symbol-whitespace
        Examples are given, and this can be searched for
        programmatically.  The use of character markup applies
        *only* to text paragraphs, *not* to code samples!
      - Asterisks are used for an inflectional emphasis.  For
        example, "All good boys *deserve* fudge."  This would
        typically be indicated typographically with boldface or
        italics.
      - Underscores are used for book/journal citation.  For
        example, "Knuth's _Art of Computer Programming_ is
        essential."  This would typically be indicated
        typographically with italics or underline.
      - Single-stroke is used to indicate filenames and function
        names.  For example, "Every C program has a 'main()'
        function."  This might be indicated typographically by a
        fixed font, by boldface, or simply by single-quotes.
      - Braces are used to indicate a module, package or library.
        For example, "The [cre] module will replace [re] in
        Python 1.6."  This will probably be indicated
        typographically as a fixed font.
      - Double-stroke is used as either inline quotation or scare
        quotes.  For example, "It may not be as "easy" as
        suggested."  In either case, typographic quotes are
        probably the best format; italics would make some sense
        also.
      - Parenthesis are used, and should be preserved as is.
      - Angle brackets and curly brackets have no special meaning
        yet.  I may choose to use those if there is something I
        think the above forms do not capture.
      - Em-dashes, diacritics, ligatures, and typographic
        quotations are not available, and standard ASCII
        approximations are used.
-
      #--- Miscellany: ---#
      - URL's are automatically transformed into a hotlink.
        Basically, anything that starts with 'http://', 'ftp://',
        'file://' or 'gopher://' looks like a URL to the program.

"""</FONT>
__doc__=__oneliner__+__longdoc__
__comments__=<FONT COLOR=#115511>"""
  This script utilizes the services of the Marc-Andre Lemburg's Python
  Highlighter for HTML (v0.5+) [py2html].  [py2html] in turn relies on
  Just van Rossum's [PyFontify] (v.0.3.1+) If these are not present,
  Txt2HTML hopes to degrade gracefully, but will not provide syntax
  highlighting for Python source code.
"""</FONT>
__author__=[<FONT COLOR=#115511>"David Mertz (mertz@gnosis.cx)"</FONT>,]
__copyright__=<FONT COLOR=#115511>"""
    This file is released to the public domain.  I (dqm) would
    appreciate it if you choose to keep derived works under terms
    that promote freedom, but obviously am giving up any rights
    to compel such.
"""</FONT>
__version__=<FONT COLOR=#115511>"version 0.2 (August 2000)"</FONT>

<FONT COLOR=#1111CC>#-- import stuff, or at least try</FONT>
<FONT COLOR=#3333CC><B>import</B></FONT> py2html, sys, re, string, time
<FONT COLOR=#3333CC><B>from</B></FONT> urllib <FONT COLOR=#3333CC><B>import</B></FONT> urlopen
<FONT COLOR=#3333CC><B>from</B></FONT> cStringIO <FONT COLOR=#3333CC><B>import</B></FONT> *
<FONT COLOR=#3333CC><B>try</B></FONT>:
    <FONT COLOR=#3333CC><B>import</B></FONT> py2html
    py_formatter = 1
<FONT COLOR=#3333CC><B>except</B></FONT>:
    py_formatter = 0

<FONT COLOR=#1111CC>#-- Define some HTML boilerplate</FONT>
cgi_home = <FONT COLOR=#115511>"http://gnosis.cx/cgi-bin/"</FONT>
html_open =\
<FONT COLOR=#115511>"""&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;%s&lt;/title&gt;
&lt;style&gt;
             {font-family: helvetica, helv, arial, sans-serif; font-size: 10pt; text-align: left}
em           {font-family: helvetica, helv, arial, sans-serif; font-size: 10pt}
ul, ol, li   {font-family: helvetica, helv, arial, sans-serif; font-size: 10pt; text-align: left}
tt           {font-family: mono, courier}
pre          {font-family: mono; font-size: 9pt}
th           {font-family: mono, courier; font-size: 8pt}

.code-sample {background-color: #CCCCCC}
.sidebar     {background-color: #FFFFCC}
.title       {font-size: medium; color: #3333CC}
.subtitle    {font-size: 9pt; color: #3333CC}
.subhead     {font-size: 12pt}
.input       {background: #FFFFFF; color: #000000; font-weight: normal}
&lt;/style&gt;
&lt;/head&gt;
&lt;body bgcolor="#ffffff" text="#000000"&gt;
"""</FONT>
html_title = <FONT COLOR=#115511>"Automatically Generated HTML"</FONT>
html_close = <FONT COLOR=#115511>"&lt;/body&gt;&lt;/html&gt;"</FONT>
code_block = \
<FONT COLOR=#115511>"""&lt;p&gt;&lt;strong&gt;%s&lt;/strong&gt;
&lt;table border="0" cellpadding="0" class="code-sample" width="100%%"&gt;&lt;tr&gt;&lt;td&gt;
%s
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/p&gt;
"""</FONT>
promo = <FONT COLOR=#115511>"""
&lt;table cellpadding=0 cellspacing=0 border=0 bgcolor="#000000" width="99%%" align=center&gt;
  &lt;tr&gt;&lt;td&gt;
    &lt;table width="100%%" cellspacing=1 cellpadding=3 border=0&gt;
      &lt;form method="get" action='"""</FONT>+cgi_home+<FONT COLOR=#115511>"""txt2html.cgi'&gt;
      &lt;tr&gt;&lt;td bgcolor="#cccccc"&gt;
        &lt;a href='"""</FONT>+cgi_home+<FONT COLOR=#115511>"""txt2html.cgi?source=../rc/nicelinks.txt'&gt;
        &lt;img src='http://gnosis.cx/rc/eye.gif' border=0 alt="More"
             align="right" align="top"&gt;&lt;/a&gt;&nbsp;
        URL to convert:
              &lt;input type="text" name="source" size=65 value="%(source)s"&gt;&lt;br&gt;
        Conversion Type: &lt;select name="type"&gt;
              &lt;option selected&gt;INFER
              &lt;option&gt;SIMPLE
              &lt;option&gt;SMART_ASCII
              &lt;option&gt;FAQ
              &lt;option&gt;PYTHON
              &lt;option&gt;RAW
              &lt;option&gt;HTML &lt;/select&gt;&nbsp;
        Proxy-mode: &lt;select name="proxy"&gt;
              &lt;option&gt;NAVIGATOR
              &lt;option&gt;TRAP_LINKS
              &lt;option selected&gt;ALL
              &lt;option&gt;NONE &lt;/select&gt;&nbsp;
        &lt;input type="submit" name="go" value="Display!"&gt;
      &lt;/td&gt;&lt;/tr&gt;
      &lt;/form&gt;
      &lt;tr&gt;&lt;td bgcolor="#cceecc"&gt;
        Generated from &lt;tt&gt;%(source)s&lt;/tt&gt; by
        &lt;a href="http://gnosis.cx/download/txt2html.zip"&gt;&lt;tt&gt;Txt2Html&lt;/tt&gt;&lt;/a&gt;
      &lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
  &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
"""</FONT>
<FONT COLOR=#1111CC>#-- End of boilerplate</FONT>

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="main"><FONT COLOR=#CC0000><B> main</B></FONT></A>(cfg_dict):
    <FONT COLOR=#115511>"""Process input source, as per configuration dictionary.

    Just one value is passed to txt2html.main(): a dictionary of operation
    options.  The dictionary must hold the following keys:

        'source':  URL of source (or local filename) or '&lt;STDIN&gt;'
        'target':  Filename of output or '&lt;STDOUT&gt;'
        'preface': (optional) HTTP header for output, esp. if CGI
        'type':    (of input) 'HTML','SMART_ASCII','PYTHON','SIMPLE',...
        'proxy':   'NAVIGATOR', 'TRAP_LINKS', 'ALL', 'NONE'

    """</FONT>
    replace = string.replace

    <FONT COLOR=#1111CC>#-- Read the configuration, set options</FONT>
    source = cfg_dict[<FONT COLOR=#115511>'source'</FONT>]
    <FONT COLOR=#3333CC><B>if</B></FONT> source == <FONT COLOR=#115511>'&lt;STDIN&gt;'</FONT>:
        fhin = sys.stdin
        cfg_dict[<FONT COLOR=#115511>'source'</FONT>] = <FONT COLOR=#115511>'&lt;STDIN&gt;'</FONT>
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        <FONT COLOR=#3333CC><B>try</B></FONT>:
            fhin = urlopen(source)
        <FONT COLOR=#3333CC><B>except</B></FONT>:
            ErrReport(source+<FONT COLOR=#115511>' could not be opened!'</FONT>, cfg_dict)
            <FONT COLOR=#3333CC><B>return</B></FONT>

    target = cfg_dict[<FONT COLOR=#115511>'target'</FONT>]
    <FONT COLOR=#3333CC><B>if</B></FONT> target == <FONT COLOR=#115511>'&lt;STDOUT&gt;'</FONT>:
        fhout = sys.stdout
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        fhout = open(target, <FONT COLOR=#115511>'w'</FONT>)

    <FONT COLOR=#1111CC>#-- Get intype and the regex list</FONT>
    intype = cfg_dict[<FONT COLOR=#115511>'type'</FONT>]
    re_list = Regex_by_filetype(intype)

    <FONT COLOR=#1111CC>#-- Process as needed for input type</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> intype <FONT COLOR=#3333CC><B>in</B></FONT> [<FONT COLOR=#115511>'HTML'</FONT>]:
        <FONT COLOR=#3333CC><B>if</B></FONT> cfg_dict.has_key(<FONT COLOR=#115511>'preface'</FONT>): fhout.write(cfg_dict[<FONT COLOR=#115511>'preface'</FONT>])
        doc = <FONT COLOR=#115511>''</FONT>
        <FONT COLOR=#3333CC><B>for</B></FONT> line <FONT COLOR=#3333CC><B>in</B></FONT> fhin.readlines():   <FONT COLOR=#1111CC># Need to normalize line endings!</FONT>
            doc = doc+string.rstrip(line)+<FONT COLOR=#115511>'\n'</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> cfg_dict[<FONT COLOR=#115511>'proxy'</FONT>] <FONT COLOR=#3333CC><B>in</B></FONT> [<FONT COLOR=#115511>'ALL'</FONT>, <FONT COLOR=#115511>'NAVIGATOR'</FONT>]:   <FONT COLOR=#1111CC># proxy nav bar</FONT>
            doc = re.sub(<FONT COLOR=#115511>'(?im)(&lt;BODY(?:.*?)&gt;)'</FONT>,<FONT COLOR=#115511>'\\1'</FONT>+(promo % cfg_dict),doc)
        <FONT COLOR=#3333CC><B>if</B></FONT> cfg_dict[<FONT COLOR=#115511>'proxy'</FONT>] &lt;&gt; <FONT COLOR=#115511>'NONE'</FONT>:                 <FONT COLOR=#1111CC># absolute links</FONT>
            doc = Absolutize(doc, source)
        <FONT COLOR=#3333CC><B>if</B></FONT> cfg_dict[<FONT COLOR=#115511>'proxy'</FONT>] <FONT COLOR=#3333CC><B>in</B></FONT> [<FONT COLOR=#115511>'ALL'</FONT>, <FONT COLOR=#115511>'TRAP_LINKS'</FONT>]:  <FONT COLOR=#1111CC># proxy links</FONT>
            doc = Proxify(doc, cgi_home+<FONT COLOR=#115511>'txt2html.cgi?source='</FONT>)
        fhout.write(doc)
    <FONT COLOR=#3333CC><B>elif</B></FONT> intype <FONT COLOR=#3333CC><B>in</B></FONT> [<FONT COLOR=#115511>'SMART_ASCII'</FONT>]:
        <FONT COLOR=#1111CC>#sys.stderr.write('           start: ' + time.ctime(time.time())+"\n")</FONT>
        blocks = Make_Blocks(fhin, re_list)
        <FONT COLOR=#1111CC>#sys.stderr.write('     blocks made: ' + time.ctime(time.time())+"\n")</FONT>
        Process_Blocks(fhout, blocks, cfg_dict, title_block=1)
        <FONT COLOR=#1111CC>#sys.stderr.write('blocks processed: ' + time.ctime(time.time())+"\n")</FONT>
    <FONT COLOR=#3333CC><B>elif</B></FONT> intype <FONT COLOR=#3333CC><B>in</B></FONT> [<FONT COLOR=#115511>'PYTHON'</FONT>, <FONT COLOR=#115511>'FAQ'</FONT>, <FONT COLOR=#115511>'SIMPLE'</FONT>, <FONT COLOR=#115511>'RAW'</FONT>]:
        blocks = Make_Blocks(fhin, re_list)
        Process_Blocks(fhout, blocks, cfg_dict)
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        ErrReport(<FONT COLOR=#115511>'Something is amiss with filetype detection'</FONT>, cfg_dict)
        <FONT COLOR=#3333CC><B>return</B></FONT>

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="Make_Blocks"><FONT COLOR=#CC0000><B> Make_Blocks</B></FONT></A>(fhin, re_list):
    <FONT COLOR=#1111CC>#-- Initialize the globals</FONT>
    <FONT COLOR=#3333CC><B>global</B></FONT> state, blocks, bl_num, newblock
    state = <FONT COLOR=#115511>"HEADER"</FONT>
    blocks = [<FONT COLOR=#115511>""</FONT>]
    bl_num = 0
    newblock = 1

    <FONT COLOR=#1111CC>#-- Unpack the regex list</FONT>
    blankln, headln, textln, quoteln, codeln = re_list

    <FONT COLOR=#1111CC>#-- Break the file into relevant chunks</FONT>
    <FONT COLOR=#3333CC><B>for</B></FONT> line <FONT COLOR=#3333CC><B>in</B></FONT> fhin.readlines():
        line = string.rstrip(line)+<FONT COLOR=#115511>'\n'</FONT>  <FONT COLOR=#1111CC># Need to normalize line endings!</FONT>

        <FONT COLOR=#3333CC><B>if</B></FONT> state == <FONT COLOR=#115511>"HEADER"</FONT>:         <FONT COLOR=#1111CC># blank line means new block of ??</FONT>
            <FONT COLOR=#3333CC><B>if</B></FONT> blankln.match(line):   newblock = 1
            <FONT COLOR=#3333CC><B>elif</B></FONT> textln.match(line):  startText(line)
            <FONT COLOR=#3333CC><B>elif</B></FONT> quoteln.match(line): startQuote(line)
            <FONT COLOR=#3333CC><B>elif</B></FONT> codeln.match(line):  startCode(line)
            <FONT COLOR=#3333CC><B>else</B></FONT>:
                <FONT COLOR=#3333CC><B>if</B></FONT> newblock: startHead(line)
                <FONT COLOR=#3333CC><B>else</B></FONT>: blocks[bl_num] = blocks[bl_num] + line

        <FONT COLOR=#3333CC><B>elif</B></FONT> state == <FONT COLOR=#115511>"TEXT"</FONT>:         <FONT COLOR=#1111CC># blank line means new block of ??</FONT>
            <FONT COLOR=#3333CC><B>if</B></FONT> blankln.match(line):   newblock = 1
            <FONT COLOR=#3333CC><B>elif</B></FONT> headln.match(line):  startHead(line)
            <FONT COLOR=#3333CC><B>elif</B></FONT> quoteln.match(line): startQuote(line)
            <FONT COLOR=#3333CC><B>elif</B></FONT> codeln.match(line):  startCode(line)
            <FONT COLOR=#3333CC><B>else</B></FONT>:
                <FONT COLOR=#3333CC><B>if</B></FONT> newblock: startText(line)
                <FONT COLOR=#3333CC><B>else</B></FONT>: blocks[bl_num] = blocks[bl_num] + line

        <FONT COLOR=#3333CC><B>elif</B></FONT> state == <FONT COLOR=#115511>"QUOTE"</FONT>:        <FONT COLOR=#1111CC># blank line means new block of ??</FONT>
            <FONT COLOR=#3333CC><B>if</B></FONT> blankln.match(line):   newblock = 1
            <FONT COLOR=#3333CC><B>elif</B></FONT> headln.match(line):  startHead(line)
            <FONT COLOR=#3333CC><B>elif</B></FONT> textln.match(line):  startText(line)
            <FONT COLOR=#1111CC># do not transition quote-&gt;code without a blank line</FONT>
            <FONT COLOR=#1111CC># elif codeln.match(line):  startCode(line)</FONT>
            <FONT COLOR=#3333CC><B>else</B></FONT>:
                <FONT COLOR=#3333CC><B>if</B></FONT> newblock:  startQuote(line)
                <FONT COLOR=#3333CC><B>else</B></FONT>: blocks[bl_num] = blocks[bl_num] + line

        <FONT COLOR=#3333CC><B>elif</B></FONT> state == <FONT COLOR=#115511>"CODE"</FONT>:         <FONT COLOR=#1111CC># blank line does not change state</FONT>
            <FONT COLOR=#3333CC><B>if</B></FONT> blankln.match(line):   blocks[bl_num] = blocks[bl_num] + line
            <FONT COLOR=#3333CC><B>elif</B></FONT> headln.match(line):  startHead(line)
            <FONT COLOR=#3333CC><B>elif</B></FONT> textln.match(line):  startText(line)
            <FONT COLOR=#3333CC><B>else</B></FONT>: blocks[bl_num] = blocks[bl_num] + line

        <FONT COLOR=#3333CC><B>else</B></FONT>:
            <FONT COLOR=#3333CC><B>raise</B></FONT> ValueError, <FONT COLOR=#115511>"unexpected input block state: "</FONT>+state

    <FONT COLOR=#3333CC><B>return</B></FONT> blocks

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="Process_Blocks"><FONT COLOR=#CC0000><B> Process_Blocks</B></FONT></A>(fhout, blocks, cfg_dict, title_block=0):
    <FONT COLOR=#1111CC># Process all blocks, then write out headers and body</FONT>
    <FONT COLOR=#1111CC># (performance might be snappier in CGI if we wrote block-by-block...)</FONT>

    <FONT COLOR=#1111CC>#-- check for server errors</FONT>
    re_err = re.compile(<FONT COLOR=#115511>'^.*&lt;TITLE&gt;.*(404)|(403).*&lt;/TITLE&gt;'</FONT>, re.I | re.S | re.M)
    block = string.join(blocks[0:3])
    <FONT COLOR=#3333CC><B>if</B></FONT> re_err.match(block):
        html_title = <FONT COLOR=#115511>'Server reported error on URL'</FONT>
        re_body = re.compile(<FONT COLOR=#115511>'&lt;BODY(?:.*?)&gt;(.*)&lt;/BODY&gt;'</FONT>, re.I | re.M | re.S)
        body = re_body.match(block).group(1)
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        <FONT COLOR=#1111CC># Worry about having the right number of blocks</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> len(blocks) == 1:
            blocks = [<FONT COLOR=#115511>''</FONT>,cfg_dict[<FONT COLOR=#115511>'type'</FONT>],cfg_dict[<FONT COLOR=#115511>'source'</FONT>],
                      <FONT COLOR=#115511>'Weird failure parsing source experienced!'</FONT>]
        <FONT COLOR=#3333CC><B>elif</B></FONT> len(blocks) &lt;= 3 <FONT COLOR=#3333CC><B>or</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> title_block:
            blocks = [<FONT COLOR=#115511>''</FONT>,<FONT COLOR=#115511>'Type of file: '</FONT>+cfg_dict[<FONT COLOR=#115511>'type'</FONT>],
                      cfg_dict[<FONT COLOR=#115511>'source'</FONT>]] + blocks[1:]

        <FONT COLOR=#1111CC># Give it a nice page title</FONT>
        html_title = string.join(string.split(blocks[1], <FONT COLOR=#115511>'\n'</FONT>),<FONT COLOR=#115511>' -- '</FONT>)
        html_title = string.replace(html_title, <FONT COLOR=#115511>'[HEAD]'</FONT>, <FONT COLOR=#115511>''</FONT>)

        <FONT COLOR=#1111CC># Massage each block as needed</FONT>
        body = Titleify(blocks[1]) + Authorify(blocks[2])
        <FONT COLOR=#3333CC><B>for</B></FONT> block <FONT COLOR=#3333CC><B>in</B></FONT> blocks[3:]:
            <FONT COLOR=#3333CC><B>if</B></FONT>   block[:6]==<FONT COLOR=#115511>'[CODE]'</FONT>: block = fixcode(block[6:],cfg_dict[<FONT COLOR=#115511>'type'</FONT>])
            <FONT COLOR=#3333CC><B>elif</B></FONT> block[:6]==<FONT COLOR=#115511>'[QUOT]'</FONT>: block = fixquote(block[6:])
            <FONT COLOR=#3333CC><B>elif</B></FONT> block[:6]==<FONT COLOR=#115511>'[TEXT]'</FONT>: block = fixtext(block[6:])
            <FONT COLOR=#3333CC><B>elif</B></FONT> block[:6]==<FONT COLOR=#115511>'[HEAD]'</FONT>: block = fixhead(block[6:])
            <FONT COLOR=#3333CC><B>else</B></FONT>: <FONT COLOR=#3333CC><B>raise</B></FONT> ValueError, <FONT COLOR=#115511>"unexpected block marker: "</FONT>+block[:6]
            <FONT COLOR=#3333CC><B>if</B></FONT> cfg_dict[<FONT COLOR=#115511>'proxy'</FONT>] <FONT COLOR=#3333CC><B>in</B></FONT> [<FONT COLOR=#115511>'ALL'</FONT>, <FONT COLOR=#115511>'TRAP_LINKS'</FONT>]:
                block = Proxify(block, cgi_home+<FONT COLOR=#115511>'txt2html.cgi?source='</FONT>)
            body = body+block

    <FONT COLOR=#1111CC>#-- Output with surrounding document HTML/HTTP</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> cfg_dict.has_key(<FONT COLOR=#115511>'preface'</FONT>):
        fhout.write(cfg_dict[<FONT COLOR=#115511>'preface'</FONT>])
    fhout.write(html_open % html_title)
    <FONT COLOR=#3333CC><B>if</B></FONT> cfg_dict[<FONT COLOR=#115511>'proxy'</FONT>] <FONT COLOR=#3333CC><B>in</B></FONT> [<FONT COLOR=#115511>'ALL'</FONT>, <FONT COLOR=#115511>'NAVIGATOR'</FONT>]:
        fhout.write(promo % cfg_dict)
    fhout.write(body)
    fhout.write(html_close)

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="ErrReport"><FONT COLOR=#CC0000><B> ErrReport</B></FONT></A>(mess, cfg_dict):
    <FONT COLOR=#3333CC><B>if</B></FONT> cfg_dict.has_key(<FONT COLOR=#115511>'preface'</FONT>):  <FONT COLOR=#3333CC><B>print</B></FONT> cfg_dict[<FONT COLOR=#115511>'preface'</FONT>]
    <FONT COLOR=#3333CC><B>print</B></FONT> (html_open % html_title)
    <FONT COLOR=#3333CC><B>if</B></FONT> cfg_dict[<FONT COLOR=#115511>'proxy'</FONT>] <FONT COLOR=#3333CC><B>in</B></FONT> [<FONT COLOR=#115511>'ALL'</FONT>, <FONT COLOR=#115511>'NAVIGATOR'</FONT>]:
        <FONT COLOR=#3333CC><B>print</B></FONT> (promo % cfg_dict)
    <FONT COLOR=#3333CC><B>print</B></FONT> <FONT COLOR=#115511>'&lt;h1&gt;'</FONT>+mess+<FONT COLOR=#115511>'&lt;/h1&gt;'</FONT>
    <FONT COLOR=#3333CC><B>print</B></FONT> html_close


<FONT COLOR=#1111CC>#-- Functions for start of block-type state</FONT>
<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="startHead"><FONT COLOR=#CC0000><B> startHead</B></FONT></A>(line):
    <FONT COLOR=#3333CC><B>global</B></FONT> state, blocks, bl_num, newblock
    state = <FONT COLOR=#115511>"HEADER"</FONT>
    bl_num = bl_num+1
    blocks.append(<FONT COLOR=#115511>'[HEAD]'</FONT>+line)
    newblock = 0

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="startText"><FONT COLOR=#CC0000><B> startText</B></FONT></A>(line):
    <FONT COLOR=#3333CC><B>global</B></FONT> state, blocks, bl_num, newblock
    state = <FONT COLOR=#115511>"TEXT"</FONT>
    bl_num = bl_num+1
    blocks.append(<FONT COLOR=#115511>'[TEXT]'</FONT>+line)
    newblock = 0

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="startQuote"><FONT COLOR=#CC0000><B> startQuote</B></FONT></A>(line):
    <FONT COLOR=#3333CC><B>global</B></FONT> state, blocks, bl_num, newblock
    state = <FONT COLOR=#115511>"QUOTE"</FONT>
    bl_num = bl_num+1
    blocks.append(<FONT COLOR=#115511>'[QUOT]'</FONT>+line)
    newblock = 0

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="startCode"><FONT COLOR=#CC0000><B> startCode</B></FONT></A>(line):
    <FONT COLOR=#3333CC><B>global</B></FONT> state, blocks, bl_num, newblock
    state = <FONT COLOR=#115511>"CODE"</FONT>
    bl_num = bl_num+1
    blocks.append(<FONT COLOR=#115511>'[CODE]'</FONT>+line)
    newblock = 0


<FONT COLOR=#1111CC>#-- Functions to massage blocks by type</FONT>
<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="Titleify"><FONT COLOR=#CC0000><B> Titleify</B></FONT></A>(block):
    title, subtitle, other = (<FONT COLOR=#115511>'No Title'</FONT>, <FONT COLOR=#115511>''</FONT>, <FONT COLOR=#115511>''</FONT>)
    block = string.replace(block, <FONT COLOR=#115511>'[HEAD]'</FONT>, <FONT COLOR=#115511>''</FONT>)
    <FONT COLOR=#1111CC>#block = string.strip(block)</FONT>
    block = Typographify(block)
    lines = string.split(block, <FONT COLOR=#115511>'\n'</FONT>)
    <FONT COLOR=#3333CC><B>if</B></FONT> len(lines) &gt; 0:
        title = lines[0]
    title = string.capwords(title)
    <FONT COLOR=#3333CC><B>if</B></FONT> len(lines) &gt; 1:
        subtitle = lines[1]
    <FONT COLOR=#3333CC><B>for</B></FONT> i <FONT COLOR=#3333CC><B>in</B></FONT> range(2,len(lines)):
        other = other+<FONT COLOR=#115511>'&lt;br&gt;'</FONT>+lines[i]+<FONT COLOR=#115511>'\n'</FONT>
    block = <FONT COLOR=#115511>"""
&lt;p&gt;&lt;strong class="title"&gt;%s&lt;/strong&gt;&lt;br&gt;
&lt;strong class="subtitle"&gt;%s&lt;/strong&gt;&lt;/p&gt;
 %s"""</FONT> % (title, subtitle, other)
    <FONT COLOR=#3333CC><B>return</B></FONT> block

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="Authorify"><FONT COLOR=#CC0000><B> Authorify</B></FONT></A>(block):
    block = string.replace(block, <FONT COLOR=#115511>'[HEAD]'</FONT>, <FONT COLOR=#115511>''</FONT>)
    <FONT COLOR=#1111CC>#block = string.strip(block)</FONT>
    lines = string.split(block, <FONT COLOR=#115511>'\n'</FONT>)
    block = <FONT COLOR=#115511>"&lt;p&gt;"</FONT> +string.join(map(<FONT COLOR=#3333CC><B>lambda</B></FONT> ln:  ln+<FONT COLOR=#115511>'&lt;br&gt;\n'</FONT>, lines))+<FONT COLOR=#115511>"&lt;/p&gt;\n"</FONT>
    block = Typographify(block)
    <FONT COLOR=#3333CC><B>return</B></FONT> block

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="fixcode"><FONT COLOR=#CC0000><B> fixcode</B></FONT></A>(block, doctype):
    <FONT COLOR=#1111CC># Some HTML preparation</FONT>
    block = Detag(block)
    block = LeftMargin(block)

    <FONT COLOR=#1111CC># Pull out title if available</FONT>
    re_title = re.compile(<FONT COLOR=#115511>'^#\-+ (.+) \-+#$'</FONT>, re.M)
    if_title = re_title.match(block)
    <FONT COLOR=#3333CC><B>if</B></FONT> if_title:
        title = if_title.group(1)
        block = re_title.sub(<FONT COLOR=#115511>''</FONT>, block)  <FONT COLOR=#1111CC># take title out of code</FONT>
    <FONT COLOR=#3333CC><B>else</B></FONT>: title = <FONT COLOR=#115511>''</FONT>
    <FONT COLOR=#1111CC>#block = string.strip(block)      # no surrounding whitespace</FONT>

    <FONT COLOR=#1111CC># Process the code block with Py2HTML (if possible and appropriate)</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> py_formatter <FONT COLOR=#3333CC><B>and</B></FONT> (string.count(title,<FONT COLOR=#115511>'.py'</FONT>) <FONT COLOR=#3333CC><B>or</B></FONT>
                         string.count(title,<FONT COLOR=#115511>'Python'</FONT>) <FONT COLOR=#3333CC><B>or</B></FONT>
                         string.count(title,<FONT COLOR=#115511>'python'</FONT>) <FONT COLOR=#3333CC><B>or</B></FONT>
                         doctype == <FONT COLOR=#115511>'PYTHON'</FONT>):
        fh = open(<FONT COLOR=#115511>'tmp'</FONT>, <FONT COLOR=#115511>'w'</FONT>)
        fh.write(block)
        fh.close()
        py2html.main([None, <FONT COLOR=#115511>'-format:rawhtml'</FONT>, <FONT COLOR=#115511>'tmp'</FONT>])
        block = open(<FONT COLOR=#115511>'tmp.html'</FONT>).read()
        block = code_block % (title, block)
    <FONT COLOR=#1111CC># elif the-will-and-the-way-is-there-to-format-language-X:</FONT>
    <FONT COLOR=#1111CC># elif the-will-and-the-way-is-there-to-format-language-Y:</FONT>
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        block = code_block % (title, <FONT COLOR=#115511>'&lt;pre&gt;'</FONT>+block+<FONT COLOR=#115511>'&lt;/pre&gt;'</FONT>)
    <FONT COLOR=#3333CC><B>return</B></FONT> block

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="fixquote"><FONT COLOR=#CC0000><B> fixquote</B></FONT></A>(block):
    block = Detag(block)
    block = Typographify(block)
    block = <FONT COLOR=#115511>'&lt;blockquote&gt;%s&lt;/blockquote&gt;'</FONT> % block
    block = URLify(block)
    <FONT COLOR=#3333CC><B>return</B></FONT> block

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="fixtext"><FONT COLOR=#CC0000><B> fixtext</B></FONT></A>(block):
    block = Detag(block)
    block = Rulify(block)
    block = Typographify(block)
    block = <FONT COLOR=#115511>'&lt;p&gt;%s&lt;/p&gt;\n'</FONT> % block
    block = URLify(block)
    <FONT COLOR=#3333CC><B>return</B></FONT> block

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="fixhead"><FONT COLOR=#CC0000><B> fixhead</B></FONT></A>(block):
    block = Detag(block)
    block = NoRule(block)
    <FONT COLOR=#1111CC>#block = string.strip(block)</FONT>
    block = AdjustCaps(block)
    block = Typographify(block+<FONT COLOR=#115511>" "</FONT>)
    <FONT COLOR=#3333CC><B>return</B></FONT> block


<FONT COLOR=#1111CC>#-- Utility functions for text transformation</FONT>
<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="AdjustCaps"><FONT COLOR=#CC0000><B> AdjustCaps</B></FONT></A>(txt):
    <FONT COLOR=#1111CC># Bare header is block in ALLCAPS (excluding [module] names)</FONT>
    non_lit = re.sub(<FONT COLOR=#115511>"['[].*[]']"</FONT>, <FONT COLOR=#115511>''</FONT>, txt)
    <FONT COLOR=#3333CC><B>if</B></FONT> non_lit == string.upper(non_lit):
        txt = capwords(txt)
        txt = <FONT COLOR=#115511>'&lt;p&gt;&lt;strong class="subhead"&gt;%s&lt;/strong&gt;&lt;/p&gt;\n'</FONT> % txt
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        txt = <FONT COLOR=#115511>'&lt;h3&gt;%s&lt;/h3&gt;'</FONT> % txt
        txt = URLify(txt)
    <FONT COLOR=#3333CC><B>return</B></FONT> txt

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="capwords"><FONT COLOR=#CC0000><B> capwords</B></FONT></A>(txt):
    <FONT COLOR=#115511>"""string.capwords does'nt do what we want for 'quoted' stuff"""</FONT>
    words = string.split(txt)
    <FONT COLOR=#3333CC><B>for</B></FONT> n <FONT COLOR=#3333CC><B>in</B></FONT> range(len(words)):
        <FONT COLOR=#3333CC><B>if</B></FONT> <FONT COLOR=#3333CC><B>not</B></FONT> words[n][0] <FONT COLOR=#3333CC><B>in</B></FONT> <FONT COLOR=#115511>"'["</FONT>: words[n] = string.capwords(words[n])
    <FONT COLOR=#3333CC><B>return</B></FONT> string.join(words, <FONT COLOR=#115511>' '</FONT>)

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="LeftMargin"><FONT COLOR=#CC0000><B> LeftMargin</B></FONT></A>(txt):
    <FONT COLOR=#115511>"""Remove as many leading spaces as possible from whole block"""</FONT>
    <FONT COLOR=#3333CC><B>for</B></FONT> l <FONT COLOR=#3333CC><B>in</B></FONT> range(12,-1,-1):
        re_lead = <FONT COLOR=#115511>'(?sm)'</FONT>+<FONT COLOR=#115511>' '</FONT>*l+<FONT COLOR=#115511>'\S'</FONT>
        <FONT COLOR=#3333CC><B>if</B></FONT> re.match(re_lead, txt): <FONT COLOR=#3333CC><B>break</B></FONT>
    txt = re.sub(<FONT COLOR=#115511>'(?sm)^'</FONT>+<FONT COLOR=#115511>' '</FONT>*l, <FONT COLOR=#115511>''</FONT>, txt)
    <FONT COLOR=#3333CC><B>return</B></FONT> txt

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="Detag"><FONT COLOR=#CC0000><B> Detag</B></FONT></A>(txt):
    txt = string.replace(txt, <FONT COLOR=#115511>'&'</FONT>, <FONT COLOR=#115511>'&amp;'</FONT>)
    txt = string.replace(txt, <FONT COLOR=#115511>'&lt;'</FONT>, <FONT COLOR=#115511>'&lt;'</FONT>)
    txt = string.replace(txt, <FONT COLOR=#115511>'&gt;'</FONT>, <FONT COLOR=#115511>'&gt;'</FONT>)
    <FONT COLOR=#3333CC><B>return</B></FONT> txt

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="URLify"><FONT COLOR=#CC0000><B> URLify</B></FONT></A>(txt):
    txt0 = txt
    <FONT COLOR=#1111CC># Convert special IMG URL's, e.g. {Alt Text: http://site.org/img.png}</FONT>
    <FONT COLOR=#1111CC># (don't actually try quite as hard to validate URL though)</FONT>
    txt = re.sub(<FONT COLOR=#115511>'(?sm){(.*?):\s*(http://.*)}'</FONT>, <FONT COLOR=#115511>'&lt;img src="\\2" alt="\\1"&gt;'</FONT>, txt)

    <FONT COLOR=#1111CC># Convert regular URL's</FONT>
    txt = re.sub(<FONT COLOR=#115511>'(?:[^="])((?:http|ftp|gopher|file)://(?:[^ \n\r&lt;\)]+))(\s)'</FONT>,
                 <FONT COLOR=#115511>'&lt;a href="\\1"&gt;\\1&lt;/a&gt;\\2'</FONT>, txt)
    <FONT COLOR=#3333CC><B>return</B></FONT> txt

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="Proxify"><FONT COLOR=#CC0000><B> Proxify</B></FONT></A>(txt, cgi_prog):
    txt = re.sub(<FONT COLOR=#115511>"""(?i)(&lt;a href=["']?)"""</FONT>, <FONT COLOR=#115511>'\\1'</FONT>+cgi_prog, txt)
    <FONT COLOR=#3333CC><B>return</B></FONT> txt

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="Absolutize"><FONT COLOR=#CC0000><B> Absolutize</B></FONT></A>(txt, base_href):
    <FONT COLOR=#115511>"""Convert all relative links to absolute links"""</FONT>

    <FONT COLOR=#1111CC># Does base look right (not like &lt;STDIN&gt; or filename, basically)?</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> string.count(base_href, <FONT COLOR=#115511>"://"</FONT>):
        txt = string.replace(txt, <FONT COLOR=#115511>'&lt;HEAD&gt;'</FONT>, <FONT COLOR=#115511>'&lt;HEAD&gt;&lt;base href="'</FONT>+base_href+<FONT COLOR=#115511>'"&gt;'</FONT>)
        txt = string.replace(txt, <FONT COLOR=#115511>'&lt;head&gt;'</FONT>, <FONT COLOR=#115511>'&lt;head&gt;&lt;base href="'</FONT>+base_href+<FONT COLOR=#115511>'"&gt;'</FONT>)
        base_path = re.sub(<FONT COLOR=#115511>'(.*/).*'</FONT>, <FONT COLOR=#115511>'\\1'</FONT>, base_href)    <FONT COLOR=#1111CC># extract path portion</FONT>
        txt = re.sub(<FONT COLOR=#115511>"""(?im)(&lt;a href=["']?)(?!\w+://)(.*?&gt;)"""</FONT>,
                     <FONT COLOR=#115511>'\\1'</FONT>+base_path+<FONT COLOR=#115511>'\\2'</FONT>, txt)
    <FONT COLOR=#3333CC><B>return</B></FONT> txt

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="Rulify"><FONT COLOR=#CC0000><B> Rulify</B></FONT></A>(txt):
    <FONT COLOR=#3333CC><B>return</B></FONT> re.compile(<FONT COLOR=#115511>'^-+$'</FONT>, re.M).sub(<FONT COLOR=#115511>'&lt;hr&gt;'</FONT>, txt)

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="NoRule"><FONT COLOR=#CC0000><B> NoRule</B></FONT></A>(txt):
    <FONT COLOR=#3333CC><B>return</B></FONT> re.compile(<FONT COLOR=#115511>'^-+$'</FONT>, re.M).sub(<FONT COLOR=#115511>''</FONT>, txt)

<FONT COLOR=#3333CC><B>try</B></FONT>:
    <FONT COLOR=#3333CC><B>from</B></FONT> mxTypographify <FONT COLOR=#3333CC><B>import</B></FONT> Typographify
    sys.stderr.write(<FONT COLOR=#115511>"** Using mxTypographify **\n"</FONT>)
<FONT COLOR=#3333CC><B>except</B></FONT> ImportError:
    <FONT COLOR=#3333CC><B>def</B></FONT><A NAME="Typographify"><FONT COLOR=#CC0000><B> Typographify</B></FONT></A>(txt):
    	<FONT COLOR=#1111CC># [module] names</FONT>
    	r = re.compile(r<FONT COLOR=#115511>"""([\(\s'/"&gt;]|^)\[(.*?)\]([&lt;\s\.\),:;'"?!/-])"""</FONT>, re.M | re.S)
    	txt = r.sub(<FONT COLOR=#115511>'\\1&lt;em&gt;&lt;code&gt;\\2&lt;/code&gt;&lt;/em&gt;\\3'</FONT>,txt)
    	<FONT COLOR=#1111CC># *strongly emphasize* words</FONT>
    	r = re.compile(r<FONT COLOR=#115511>"""([\(\s'/"]|^)\*(.*?)\*([\s\.\),:;'"?!/-])"""</FONT>, re.M | re.S)
    	txt = r.sub(<FONT COLOR=#115511>'\\1&lt;strong&gt;\\2&lt;/strong&gt;\\3'</FONT>, txt)
    	<FONT COLOR=#1111CC># -emphasize- words</FONT>
    	r = re.compile(r<FONT COLOR=#115511>"""([\(\s'/"]|^)-(.*?)-([\s\.\),:;'"?!/])"""</FONT>, re.M | re.S)
    	txt = r.sub(<FONT COLOR=#115511>'\\1&lt;em&gt;\\2&lt;/em&gt;\\3'</FONT>, txt)
    	<FONT COLOR=#1111CC># _Book Title_ citations</FONT>
    	r = re.compile(r<FONT COLOR=#115511>"""([\(\s'/"]|^)_(.*?)_([\s\.\),:;'"?!/-])"""</FONT>, re.M | re.S)
    	txt = r.sub(<FONT COLOR=#115511>'\\1&lt;cite&gt;\\2&lt;/cite&gt;\\3'</FONT>, txt)
    	<FONT COLOR=#1111CC># 'Function()' names</FONT>
    	r = re.compile(r<FONT COLOR=#115511>"""([\(\s/"]|^)'(.*?)'([\s\.\),:;"?!/-])"""</FONT>, re.M | re.S)
    	txt = r.sub(<FONT COLOR=#115511>"\\1&lt;code&gt;\\2&lt;/code&gt;\\3"</FONT>, txt)
    	<FONT COLOR=#3333CC><B>return</B></FONT> txt

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="infer_type"><FONT COLOR=#CC0000><B> infer_type</B></FONT></A>(fname):
    lower = string.lower
    <FONT COLOR=#3333CC><B>if</B></FONT> lower(fname[-5:])==<FONT COLOR=#115511>'.html'</FONT> <FONT COLOR=#3333CC><B>or</B></FONT> lower(fname[-4:])==<FONT COLOR=#115511>'.htm'</FONT>:
        intype = <FONT COLOR=#115511>'HTML'</FONT>
    <FONT COLOR=#3333CC><B>elif</B></FONT> fname[-1:] <FONT COLOR=#3333CC><B>in</B></FONT> [<FONT COLOR=#115511>'.'</FONT>, <FONT COLOR=#115511>'/'</FONT>]:
        intype = <FONT COLOR=#115511>'HTML'</FONT>
    <FONT COLOR=#3333CC><B>elif</B></FONT> lower(fname[-3:])==<FONT COLOR=#115511>'.py'</FONT> <FONT COLOR=#3333CC><B>or</B></FONT> lower(fname[-4:])==<FONT COLOR=#115511>'.cgi'</FONT>:
        intype = <FONT COLOR=#115511>'PYTHON'</FONT>
    <FONT COLOR=#3333CC><B>elif</B></FONT> lower(fname[-4:])==<FONT COLOR=#115511>'.faq'</FONT>:
        intype = <FONT COLOR=#115511>'FAQ'</FONT>
    <FONT COLOR=#3333CC><B>elif</B></FONT> lower(fname[-4:])==<FONT COLOR=#115511>'.txt'</FONT>:
        intype = <FONT COLOR=#115511>'SMART_ASCII'</FONT>
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        intype = <FONT COLOR=#115511>'RAW'</FONT>
    <FONT COLOR=#3333CC><B>return</B></FONT> intype

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="Regex_by_filetype"><FONT COLOR=#CC0000><B> Regex_by_filetype</B></FONT></A>(intype):
    <FONT COLOR=#3333CC><B>if</B></FONT> intype == <FONT COLOR=#115511>'SMART_ASCII'</FONT>:
        blankln = re.compile(<FONT COLOR=#115511>"^$"</FONT>)
        headln  = re.compile(<FONT COLOR=#115511>"\S"</FONT>)        <FONT COLOR=#1111CC># no indent</FONT>
        textln  = re.compile(<FONT COLOR=#115511>"  ? ?\S"</FONT>)   <FONT COLOR=#1111CC># 1-3 spaces indent</FONT>
        quoteln = re.compile(<FONT COLOR=#115511>"    \S"</FONT>)    <FONT COLOR=#1111CC># 4 spaces indent</FONT>
        codeln  = re.compile(<FONT COLOR=#115511>"^      "</FONT>)   <FONT COLOR=#1111CC># 6+ spaces indent</FONT>
    <FONT COLOR=#3333CC><B>elif</B></FONT> intype == <FONT COLOR=#115511>'FAQ'</FONT>:                 <FONT COLOR=#1111CC># based on alt.compression FAQ</FONT>
        blankln = re.compile(<FONT COLOR=#115511>"^$"</FONT>)
        headln  = re.compile(<FONT COLOR=#115511>"(^Subject: )|(^\d\.\d[\s\.])"</FONT>)
        textln  = re.compile(<FONT COLOR=#115511>"^(?!(^\d\.\d[\s\.]))\S"</FONT>)
        quoteln = re.compile(<FONT COLOR=#115511>"^[ -] "</FONT>)
        codeln  = re.compile(<FONT COLOR=#115511>"$^"</FONT>)
    <FONT COLOR=#3333CC><B>elif</B></FONT> intype <FONT COLOR=#3333CC><B>in</B></FONT> [<FONT COLOR=#115511>'PYTHON'</FONT>, <FONT COLOR=#115511>'RAW'</FONT>]:
        blankln=headln=textln=quoteln = re.compile(<FONT COLOR=#115511>"$^"</FONT>)
        codeln = re.compile(<FONT COLOR=#115511>".*"</FONT>)
    <FONT COLOR=#3333CC><B>elif</B></FONT> intype == <FONT COLOR=#115511>'SIMPLE'</FONT>:              <FONT COLOR=#1111CC># all content is testln</FONT>
        codeln=headln=quoteln = re.compile(<FONT COLOR=#115511>"$^"</FONT>)
        blankln = re.compile(<FONT COLOR=#115511>"^$"</FONT>)
        textln = re.compile(<FONT COLOR=#115511>".*"</FONT>)
    <FONT COLOR=#3333CC><B>elif</B></FONT> intype == <FONT COLOR=#115511>'HTML'</FONT>:   <FONT COLOR=#1111CC># everything is code in HTML source</FONT>
        blankln=headln=textln=quoteln= re.compile(<FONT COLOR=#115511>"$^"</FONT>)
        codeln = re.compile(<FONT COLOR=#115511>".*"</FONT>)
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        blankln = re.compile(<FONT COLOR=#115511>"^$"</FONT>)
        headln=codeln=quoteln= re.compile(<FONT COLOR=#115511>"$^"</FONT>)
        textln = re.compile(<FONT COLOR=#115511>".*"</FONT>)
    <FONT COLOR=#3333CC><B>return</B></FONT> (blankln, headln, textln, quoteln, codeln)

<FONT COLOR=#1111CC>#-- Sort out meaning of passed arguments/variables</FONT>
<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="ParseArgs"><FONT COLOR=#CC0000><B> ParseArgs</B></FONT></A>(list):
    upper = string.upper
    cfg_dict = {<FONT COLOR=#115511>'source'</FONT>: <FONT COLOR=#115511>'&lt;STDIN&gt;'</FONT>,
                <FONT COLOR=#115511>'target'</FONT>: <FONT COLOR=#115511>'&lt;STDOUT&gt;'</FONT>,
                <FONT COLOR=#115511>'type'</FONT>: <FONT COLOR=#115511>'INFER'</FONT>,
                <FONT COLOR=#115511>'proxy'</FONT>: <FONT COLOR=#115511>'NONE'</FONT> }

    <FONT COLOR=#3333CC><B>for</B></FONT> item <FONT COLOR=#3333CC><B>in</B></FONT> list:
        <FONT COLOR=#3333CC><B>if</B></FONT> item <FONT COLOR=#3333CC><B>in</B></FONT> [<FONT COLOR=#115511>'-h'</FONT>,<FONT COLOR=#115511>'/h'</FONT>,<FONT COLOR=#115511>'-?'</FONT>,<FONT COLOR=#115511>'/?'</FONT>, <FONT COLOR=#115511>'?'</FONT>]:  <FONT COLOR=#1111CC># help screen</FONT>
            <FONT COLOR=#3333CC><B>print</B></FONT> __doc__; <FONT COLOR=#3333CC><B>return</B></FONT> None
        <FONT COLOR=#3333CC><B>if</B></FONT> item[0] <FONT COLOR=#3333CC><B>in</B></FONT> <FONT COLOR=#115511>'/-'</FONT>:                     <FONT COLOR=#1111CC># a switch!</FONT>
            <FONT COLOR=#3333CC><B>if</B></FONT> upper(item[1:5]) == <FONT COLOR=#115511>'TYPE'</FONT>:      <FONT COLOR=#1111CC># set type</FONT>
                cfg_dict[<FONT COLOR=#115511>'type'</FONT>] = upper(item[6:])
            <FONT COLOR=#3333CC><B>if</B></FONT> upper(item[1:6]) == <FONT COLOR=#115511>'PROXY'</FONT>:     <FONT COLOR=#1111CC># set proxy mode</FONT>
                cfg_dict[<FONT COLOR=#115511>'proxy'</FONT>] = upper(item[7:])
            <FONT COLOR=#3333CC><B>if</B></FONT> upper(item[1:]) == <FONT COLOR=#115511>'REBUILD_DOCS'</FONT>:
                fhtxt = open(<FONT COLOR=#115511>'txt2html.txt'</FONT>, <FONT COLOR=#115511>'w'</FONT>)
                auth = string.join(__author__, <FONT COLOR=#115511>'\n'</FONT>)
                docs = (<FONT COLOR=#115511>'DMTXT2HTML.PY\n'</FONT>+__oneliner__+<FONT COLOR=#115511>'\n'</FONT>+
                        <FONT COLOR=#115511>'\n'</FONT>+auth+<FONT COLOR=#115511>'\n'</FONT>+__version__+<FONT COLOR=#115511>'\n'</FONT>+
                        __copyright__+<FONT COLOR=#115511>'\n'</FONT>+
                        __longdoc__+__comments__)
                fhtxt.write(docs)
                fhtxt.close()
                cfg_dict[<FONT COLOR=#115511>'source'</FONT>] = <FONT COLOR=#115511>'txt2html.txt'</FONT>
        <FONT COLOR=#3333CC><B>else</B></FONT>:                                   <FONT COLOR=#1111CC># not switch, set source</FONT>
            cfg_dict[<FONT COLOR=#115511>'source'</FONT>] = item

    <FONT COLOR=#3333CC><B>if</B></FONT> cfg_dict[<FONT COLOR=#115511>'type'</FONT>] == <FONT COLOR=#115511>'INFER'</FONT>:
        cfg_dict[<FONT COLOR=#115511>'type'</FONT>] = infer_type(cfg_dict[<FONT COLOR=#115511>'source'</FONT>])

    <FONT COLOR=#3333CC><B>global</B></FONT> promo        <FONT COLOR=#1111CC># fix up proxy navigation bar</FONT>
    promo = string.replace(promo, cgi_home, <FONT COLOR=#115511>''</FONT>)
    <FONT COLOR=#3333CC><B>return</B></FONT> cfg_dict

<FONT COLOR=#3333CC><B>def</B></FONT><A NAME="ParseCGI"><FONT COLOR=#CC0000><B> ParseCGI</B></FONT></A>():
    <FONT COLOR=#3333CC><B>import</B></FONT> cgi
    upper = string.upper
    cfg_dict = {<FONT COLOR=#115511>'target'</FONT>: <FONT COLOR=#115511>'&lt;STDOUT&gt;'</FONT>}
    sys.stderr = sys.stdout
    form = cgi.FieldStorage()
    <FONT COLOR=#3333CC><B>if</B></FONT> form.has_key(<FONT COLOR=#115511>'source'</FONT>):
        cfg_dict[<FONT COLOR=#115511>'source'</FONT>] = form[<FONT COLOR=#115511>'source'</FONT>].value
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        cfg_dict[<FONT COLOR=#115511>'source'</FONT>] = <FONT COLOR=#115511>'../rc/txt2html.txt'</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> form.has_key(<FONT COLOR=#115511>'type'</FONT>) <FONT COLOR=#3333CC><B>and</B></FONT> upper(form[<FONT COLOR=#115511>'type'</FONT>].value)&lt;&gt;<FONT COLOR=#115511>'INFER'</FONT>:
        cfg_dict[<FONT COLOR=#115511>'type'</FONT>] = upper(form[<FONT COLOR=#115511>'type'</FONT>].value)
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        cfg_dict[<FONT COLOR=#115511>'type'</FONT>] = infer_type(cfg_dict[<FONT COLOR=#115511>'source'</FONT>])
    <FONT COLOR=#3333CC><B>if</B></FONT> form.has_key(<FONT COLOR=#115511>'preface'</FONT>):             <FONT COLOR=#1111CC># use with caution!</FONT>
        cfg_dict[<FONT COLOR=#115511>'preface'</FONT>] = form[<FONT COLOR=#115511>'preface'</FONT>].value
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        cfg_dict[<FONT COLOR=#115511>'preface'</FONT>] = <FONT COLOR=#115511>'Content-type: text/html\n\n'</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> form.has_key(<FONT COLOR=#115511>'proxy'</FONT>):
        cfg_dict[<FONT COLOR=#115511>'proxy'</FONT>] = form[<FONT COLOR=#115511>'proxy'</FONT>].value
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        cfg_dict[<FONT COLOR=#115511>'proxy'</FONT>] = <FONT COLOR=#115511>'ALL'</FONT>
    <FONT COLOR=#3333CC><B>return</B></FONT> cfg_dict

<FONT COLOR=#1111CC>#-- The module level code</FONT>
<FONT COLOR=#3333CC><B>if</B></FONT> __name__ == <FONT COLOR=#115511>'__main__'</FONT>:
    <FONT COLOR=#1111CC># Set options based on runmode (shell vs. CGI)</FONT>
    <FONT COLOR=#3333CC><B>if</B></FONT> len(sys.argv) &gt;= 2:
        cfg_dict = ParseArgs(sys.argv[1:])
    <FONT COLOR=#3333CC><B>else</B></FONT>:
        cfg_dict = ParseCGI()

    <FONT COLOR=#3333CC><B>if</B></FONT> cfg_dict:  main(cfg_dict)

</PRE>
                  <!--footer-->
                  </BODY>
